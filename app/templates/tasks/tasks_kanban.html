{% extends "partials/base.html" %}
{% block title %}Kanban Board{% endblock title %}

{% block extra_css %}
    <!-- Dragula css -->
    <link rel="stylesheet" href="{{ url_for('static', filename='libs/dragula/dist/dragula.min.css') }}" /> 
    <style>
        /* Fixed position for Add Task button - UPDATED */
        .tasks-list {
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        .tasks-wrapper {
            flex-grow: 1;
            overflow-y: auto;
        }
        
        .my-3 {
            position: relative;
            z-index: 1;
            margin-top: 0.75rem !important;
            margin-bottom: 0.75rem !important;
            background-color: #fff;
        }
        
        .empty-column-message {
            text-align: center;
            padding: 20px;
            color: #6c757d;
            background-color: #f8f9fa;
            border-radius: 0.25rem;
            margin: 10px 0;
            border: 1px dashed #dee2e6;
        }
        
        /* Progress bar styling unchanged */
        .progress-sm {
            height: 4px;
            margin-bottom: 0;
        }
    </style>
{% endblock extra_css %}

{% block content %}
<div class="main-content">
    <div class="page-content">
        <div class="container-fluid">
            <!-- Page Title -->
            <div class="row">
                <div class="col-12">
                    <div class="page-title-box d-sm-flex align-items-center justify-content-between bg-galaxy-transparent">
                        <h4 class="mb-sm-0" id="board-title">Kanban Board</h4>
                        <div class="page-title-right">
                            <ol class="breadcrumb m-0">
                                <li class="breadcrumb-item"><a href="{{ url_for('tasks.projects') }}">Projects</a></li>
                                <li class="breadcrumb-item active">Kanban Board</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>

            {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
            {% for category, message in messages %}
            <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert" id="flash-message">
                <i class="ri-check-double-line"></i>
                {{ message }}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
            {% endfor %}
            {% endif %}
            {% endwith %}

            <!-- Kanban Board Search -->
            <div class="card">
                <div class="card-body">
                    <div class="row g-2">
                        <div class="col-lg-auto">
                            <div class="hstack gap-2">
                                <!-- <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#projectSelectionModal"><i class="ri-add-line align-bottom me-1"></i> Select Project</button> -->
                            </div>
                        </div>
                        <div class="col-lg-3 col-auto">
                            <div class="search-box">
                                <input type="text" class="form-control search" id="search-task-options" placeholder="Search tasks...">
                                <i class="ri-search-line search-icon"></i>
                            </div>
                        </div>
                        <div class="col-auto ms-sm-auto">
                            <div class="avatar-group" id="projectTeam">
                                <!-- Team members will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Kanban Board Container -->
            <div class="tasks-board mb-3" id="kanbanboard">
                <!-- Board columns will be dynamically populated -->
            </div>
        </div>
    </div>

    {% include "partials/footer.html" %}
</div>

<!-- Project Selection Modal -->
<div class="modal fade" id="projectSelectionModal" tabindex="-1" aria-labelledby="projectSelectionModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header p-3 bg-info-subtle">
                <h5 class="modal-title" id="projectSelectionModalLabel">Select Project</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="selectProjectForm">
                    <div class="mb-3">
                        <label for="projectSelect" class="form-label">Choose a Project</label>
                        <select class="form-control" id="projectSelect" required>
                            <option value="">Select Project</option>
                            {% for project in projects %}
                            <option value="{{ project.id }}">
                                {{ project.name }} ({{ project.key }})
                            </option>
                            {% endfor %}
                        </select>
                    </div>
                    <div class="hstack gap-2 justify-content-end">
                        <button type="button" class="btn btn-light" data-bs-dismiss="modal">Close</button>
                        <button type="submit" class="btn btn-success">Load Kanban Board</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Create Task Modal -->
<div class="modal fade" id="createTaskModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header bg-light p-3">
                <h5 class="modal-title">Create Task</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <form id="createTaskForm" enctype="multipart/form-data">
                <input type="hidden" id="taskProjectId" name="project_id">
                <input type="hidden" id="taskStatusId" name="status_id">
                
                <div class="modal-body">
                    <!-- Tab Navigation -->
                    <ul class="nav nav-tabs nav-tabs-custom nav-justified" role="tablist">
                        <li class="nav-item">
                            <a class="nav-link active" data-bs-toggle="tab" href="#task-details-tab" role="tab" aria-selected="true">
                                <i class="ri-task-line me-1 align-bottom"></i> Task Details
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" data-bs-toggle="tab" href="#task-attachments-tab" role="tab" aria-selected="false">
                                <i class="ri-attachment-line me-1 align-bottom"></i> Attachments
                            </a>
                        </li>
                    </ul>
                    
                    <!-- Tab Content -->
                    <div class="tab-content">
                        <!-- Task Details Tab -->
                        <div class="tab-pane active" id="task-details-tab" role="tabpanel">
                            <div class="mt-4 mb-3">
                                <label for="taskTitle" class="form-label">Title</label>
                                <input type="text" class="form-control" id="taskTitle" name="title" required>
                            </div>
                            <div class="mb-3">
                                <label for="taskDescription" class="form-label">Description</label>
                                <textarea class="form-control" id="taskDescription" name="description" rows="3"></textarea>
                            </div>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="taskCategory" class="form-label">Category</label>
                                        <select class="form-select" id="taskCategory" name="category_id">
                                            <option value="">Select Category</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="taskAssignee" class="form-label">Assignee</label>
                                        <select class="form-select" id="taskAssignee" name="assignee_id">
                                            <option value="">Unassigned</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="mb-3">
                                        <label for="taskStatus" class="form-label">Status</label>
                                        <select class="form-select" id="taskStatus" name="status_id" required>
                                            <!-- Status options will be populated -->
                                        </select>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="mb-3">
                                        <label for="taskPriority" class="form-label">Priority</label>
                                        <select class="form-select" id="taskPriority" name="priority_id" required>
                                            <option value="">Select Priority</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="mb-3">
                                        <label for="taskDueDate" class="form-label">Due Date</label>
                                        <input type="date" class="form-control" id="taskDueDate" name="due_date">
                                        <small id="dueDateHelperText" class="text-muted">
                                            <!-- This text will be updated dynamically based on project settings -->
                                        </small>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Attachments Tab -->
                        <div class="tab-pane" id="task-attachments-tab" role="tabpanel">
                            <div class="mb-3 mt-3">
                                <label for="taskAttachments" class="form-label">Attachments</label>
                                <input type="file" class="form-control" id="taskAttachments" name="attachments" multiple>
                                <div id="attachmentList" class="mt-3"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-light" data-bs-dismiss="modal">Cancel</button>
                    <button type="submit" class="btn btn-success" id="createTaskBtn">Create Task</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Create Issue Modal -->
<div class="modal fade" id="createIssueModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header bg-light p-3">
                <h5 class="modal-title">Create Issue</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <form id="createIssueForm" enctype="multipart/form-data">
                <input type="hidden" id="issueProjectId" name="project_id">
                <input type="hidden" id="issueStatusId" name="status_id">
                
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="issueType" class="form-label">Issue Type</label>
                        <select class="form-select" id="issueType" name="issue_type_id" required>
                            <!-- Issue types will be populated -->
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="issueSummary" class="form-label">Summary</label>
                        <input type="text" class="form-control" id="issueSummary" name="summary" required>
                    </div>
                    <div class="mb-3" id="epicSelectDiv" style="display: none;">
                        <label for="epicId" class="form-label">Epic</label>
                        <select class="form-select" id="epicId" name="epic_id">
                            <option value="">Select Epic</option>
                        </select>
                    </div>
                    
                    <div class="mb-3" id="storySelectDiv" style="display: none;">
                        <label for="storyId" class="form-label">Story</label>
                        <select class="form-select" id="storyId" name="story_id">
                            <option value="">Select Story</option>
                        </select>
                    </div>
                    
                    <div class="mb-3" id="taskSelectDiv" style="display: none;">
                        <label for="parentTaskId" class="form-label">Parent Task</label>
                        <select class="form-select" id="parentTaskId" name="parent_id">
                            <option value="">Select Task</option>
                        </select>
                    </div>
                    <div class="row">
                        <div class="col-lg-6">
                            <div class="mb-3">
                                <label for="issueStatus" class="form-label">Status</label>
                                <select class="form-select" id="issueStatus" name="status_id" required>
                                    <!-- Status options will be populated -->
                                </select>
                            </div>
                        </div>
                        <div class="col-lg-6">
                            <div class="mb-3">
                                <label for="issuePriority" class="form-label">Priority</label>
                                <select class="form-select" id="issuePriority" name="priority_id">
                                    <option value="">Select Priority</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-lg-6">
                            <div class="mb-3">
                                <label for="issueAssignee" class="form-label">Assignee</label>
                                <select class="form-select" id="issueAssignee" name="assignee_id">
                                    <option value="">Unassigned</option>
                                </select>
                            </div>
                        </div>
                        <div class="col-lg-6">
                            <div class="mb-3">
                                <label for="issueDueDate" class="form-label">Due Date</label>
                                <input type="date" class="form-control" id="issueDueDate" name="due_date">
                            </div>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="issueDescription" class="form-label">Description</label>
                        <textarea class="form-control" id="issueDescription" name="description" rows="3"></textarea>
                    </div>
                    <div class="row">
                        <div class="col-lg-6" id="storyPointsDiv" style="display: none;">
                            <div class="mb-3">
                                <label for="storyPoints" class="form-label">Story Points</label>
                                <input type="number" class="form-control" id="storyPoints" name="story_points">
                            </div>
                        </div>
                        <div class="col-lg-6">
                            <div class="mb-3">
                                <label for="originalEstimate" class="form-label">Original Estimate (hours)</label>
                                <input type="number" class="form-control" id="originalEstimate" name="original_estimate" step="0.5">
                            </div>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="issueAttachments" class="form-label">Attachments</label>
                        <input type="file" class="form-control" id="issueAttachments" name="attachments" multiple>
                        <div id="issueAttachmentList" class="mt-2"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <div class="hstack gap-2 justify-content-end">
                        <button type="button" class="btn btn-light" data-bs-dismiss="modal">Close</button>
                        <button type="submit" class="btn btn-success" id="createIssueBtn">Create Issue</button>
                    </div>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Delete Record Modal -->
<div class="modal fade zoomIn" id="deleteRecordModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" id="delete-btn-close"></button>
            </div>
            <div class="modal-body">
                <div class="mt-2 text-center">
                    <lord-icon src="https://cdn.lordicon.com/gsqxdxog.json" trigger="loop" colors="primary:#f7b84b,secondary:#f06548" style="width:100px;height:100px"></lord-icon>
                    <div class="mt-4 pt-2 fs-15 mx-4 mx-sm-5">
                        <h4>Are you sure?</h4>
                        <p class="text-muted mx-4 mb-0">Are you sure you want to remove this task?</p>
                    </div>
                </div>
                <div class="d-flex gap-2 justify-content-center mt-4 mb-2">
                    <button type="button" class="btn w-sm btn-light" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn w-sm btn-danger" id="delete-record">Yes, Delete It!</button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
    <!-- Dragula library for drag and drop -->
    <script src="{{ url_for('static', filename='libs/dragula/dist/dragula.min.js') }}"></script>

    <!-- Dom autoscroll for smooth scrolling during drag -->
    <script src="{{ url_for('static', filename='libs/dom-autoscroller/dist/dom-autoscroller.min.js') }}"></script>

    <!-- Kanban board script -->
    <script src="{{ url_for('static', filename='js/kanban-board.js') }}"></script>
    

<script>
    document.addEventListener('DOMContentLoaded', function() {
    // Global variables for project info
    window.currentProjectType = null;
    window.currentProjectId = null;

    // Add these variables at the top of your script to store current user information
    window.currentUserRoleId = {{ current_user.role_id }};
    window.currentUserId = {{ current_user.id }};
    
    // Check if we have a previously selected project in sessionStorage
    const savedProjectId = sessionStorage.getItem('selectedProjectId');
    
    if (savedProjectId) {
        // If we have a saved project, load it directly
        console.log('Loading previously selected project:', savedProjectId);
        loadKanbanBoardData(savedProjectId);
    } else {
        // If no saved project, show the project selection modal
        const projectSelectionModal = new bootstrap.Modal(document.getElementById('projectSelectionModal'));
        projectSelectionModal.show();
    }

    // Project selection handler - modified to save selection
    document.getElementById('selectProjectForm').addEventListener('submit', function(e) {
        e.preventDefault();
        const selectedProjectId = document.getElementById('projectSelect').value;
        
        if (selectedProjectId) {
            // Save selection to sessionStorage
            sessionStorage.setItem('selectedProjectId', selectedProjectId);
            
            // Close modal
            const projectSelectionModal = bootstrap.Modal.getInstance(document.getElementById('projectSelectionModal'));
            projectSelectionModal.hide();
            
            // Load Kanban board data
            loadKanbanBoardData(selectedProjectId);
        }
    });

    // Add a button to the UI to allow changing projects
    addChangeProjectButton();

    // Create task form submission
    document.getElementById('createTaskForm').addEventListener('submit', function(e) {
        e.preventDefault();
        createNewTask();
    });

    // Create issue form submission (if the element exists)
    const issueForm = document.getElementById('createIssueForm');
    if (issueForm) {
        issueForm.addEventListener('submit', function(e) {
            e.preventDefault();
            createNewIssue();
        });
    }

    // Issue type change handler (if the element exists)
    const issueTypeSelect = document.getElementById('issueType');
    if (issueTypeSelect) {
        issueTypeSelect.addEventListener('change', handleIssueTypeChange);
    }

    // Search functionality
    document.getElementById('search-task-options').addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase();
        filterTasks(searchTerm);
    });
    
    // Delete task handler
    document.getElementById('delete-record').addEventListener('click', function() {
        const taskId = this.getAttribute('data-task-id');
        if (taskId) {
            deleteTask(taskId);
        }
    });
    
    // Reset forms when modals are hidden
    document.getElementById('createTaskModal').addEventListener('hidden.bs.modal', function() {
        document.getElementById('createTaskForm').reset();
    });
    
    // Reset issue form when modal is hidden (if the element exists)
    const issueModal = document.getElementById('createIssueModal');
    if (issueModal) {
        issueModal.addEventListener('hidden.bs.modal', function() {
            document.getElementById('createIssueForm').reset();
        });
    }
});


function addChangeProjectButton() {
    // Find the button container (next to the Select Project button)
    const buttonContainer = document.querySelector('.col-lg-auto .hstack');
    
    if (buttonContainer) {
        // Create a new button for changing projects
        const changeProjectBtn = document.createElement('button');
        changeProjectBtn.className = 'btn btn-primary';
        changeProjectBtn.innerHTML = '<i class="ri-exchange-line align-bottom me-1"></i> Change Project';
        changeProjectBtn.addEventListener('click', function() {
            // Show the project selection modal
            const projectSelectionModal = new bootstrap.Modal(document.getElementById('projectSelectionModal'));
            projectSelectionModal.show();
        });
        
        // Add the button to the container
        buttonContainer.appendChild(changeProjectBtn);
    }
}

// Add this function to allow users to clear their selection if needed
function clearProjectSelection() {
    // Remove from sessionStorage
    sessionStorage.removeItem('selectedProjectId');
    
    // Reload the page to show the selection modal
    window.location.reload();
}

function loadKanbanBoardData(projectId) {
    console.log('Loading Kanban board for project:', projectId);
    
    // Store project ID globally 
    window.currentProjectId = projectId;
    
    // Show loading indicator
    document.getElementById('kanbanboard').innerHTML = '<div class="text-center py-5"><div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div></div>';
    
    fetch(`/tasks/api/projects/${projectId}/kanban`)
        .then(response => {
            console.log('Response status:', response.status);
            if (!response.ok) {
                return response.text().then(text => {
                    console.error('Error response:', text);
                    throw new Error(text || 'Failed to load Kanban board');
                });
            }
            return response.json();
        })
        .then(data => {
            console.log('Received data:', data);
            
            // Debug log the structure of the data
            console.log('Data structure check:');
            console.log('- project:', typeof data.project, data.project ? 'exists' : 'missing');
            console.log('- board:', typeof data.board, Array.isArray(data.board) ? `array[${data.board.length}]` : 'not array');
            console.log('- priorities:', typeof data.priorities, Array.isArray(data.priorities) ? `array[${data.priorities.length}]` : 'not array');
            console.log('- categories:', typeof data.categories, Array.isArray(data.categories) ? `array[${data.categories.length}]` : 'not array');
            
            if (data.error) {
                throw new Error(data.error);
            }

            // Validate required data
            if (!data.project || !data.project.name) {
                throw new Error('Project data is missing or invalid');
            }

            if (!data.board || !Array.isArray(data.board)) {
                console.warn('Board data is missing or not an array, using empty array');
                data.board = [];
            }

            // Update board title
            document.getElementById('board-title').textContent = `${data.project.name} Kanban Board`;
            
            // Store project info for form submissions
            document.getElementById('taskProjectId').value = data.project.id;
            if (document.getElementById('issueProjectId')) {
                document.getElementById('issueProjectId').value = data.project.id;
            }
            
            window.currentProjectLead = data.project.lead_id;
            
            // Store project type globally for use in drag and drop and modal selection
            window.currentProjectType = data.project.type;

            // Store project type globally for use in drag and drop and modal selection
            window.currentProjectType = data.project.type;
            console.log('Project type stored:', window.currentProjectType);
            
            // Ensure priorities and categories are arrays
            if (!Array.isArray(data.priorities)) {
                console.warn('Priorities is not an array, using empty array');
                data.priorities = [];
            }
            
            if (!Array.isArray(data.categories)) {
                console.warn('Categories is not an array, using empty array');
                data.categories = [];
            }
            
            // Render team members
            renderTeamMembers(data.project.team || []);
            
            // Render the board data with project information
            renderKanbanColumns(data.board, data.project);
            
            // Populate dropdowns for task/issue creation forms
            populateDropdowns(data);
            
            // Initialize drag and drop functionality
            initializeDragAndDrop();
        })
        .catch(error => {
            console.error('Error loading Kanban board:', error);
            document.getElementById('kanbanboard').innerHTML = 
                `<div class="alert alert-danger text-center" role="alert">
                    Failed to load Kanban board: ${error.message}
                </div>`;
        });
}
        
function renderTeamMembers(team) {
    const teamContainer = document.getElementById('projectTeam');
    teamContainer.innerHTML = '';
    
    // Display up to 5 team members
    team.slice(0, 5).forEach(member => {
        const memberAvatar = document.createElement('a');
        memberAvatar.href = "javascript: void(0);";
        memberAvatar.className = "avatar-group-item material-shadow";
        memberAvatar.setAttribute("data-bs-toggle", "tooltip");
        memberAvatar.setAttribute("data-bs-trigger", "hover");
        memberAvatar.setAttribute("data-bs-placement", "top");
        memberAvatar.setAttribute("title", member.name);
        
        // Check for profile picture in various possible properties
        let profileImage = '/static/images/users/user-dummy-img.jpg'; // Default image
        
        if (member.profile_picture_base64) {
            // If base64 data is available, use it directly with the proper data URL format
            profileImage = `data:image/jpeg;base64,${member.profile_picture_base64}`;
        } else if (member.avatar) {
            // Fallback to avatar property if it exists
            profileImage = member.avatar;
        }
        
        memberAvatar.innerHTML = `
            <img src="${profileImage}" alt="${member.name}" class="rounded-circle avatar-xxs">
        `;
        
        teamContainer.appendChild(memberAvatar);
    });
    
    // Add "Add More" button if there are team members
    if (team.length > 0) {
        const addMoreBtn = document.createElement('a');
        addMoreBtn.href = "javascript: void(0);"; // Updated to match other links
        addMoreBtn.className = "avatar-group-item material-shadow";
        addMoreBtn.innerHTML = `
            <div class="avatar-xxs">
                <div class="avatar-title rounded-circle">
                    +
                </div>
            </div>
        `;
        teamContainer.appendChild(addMoreBtn);
        
        // Initialize tooltips
        const tooltips = document.querySelectorAll('[data-bs-toggle="tooltip"]');
        tooltips.forEach(tooltip => new bootstrap.Tooltip(tooltip));
    }
}

function renderKanbanColumns(boardData, projectData) {
    const kanbanBoard = document.getElementById('kanbanboard');
    kanbanBoard.innerHTML = ''; // Clear existing columns
    
    // Check if we have board data
    if (!boardData || boardData.length === 0) {
        kanbanBoard.innerHTML = '<div class="alert alert-info">No columns found for this board. Please set up project statuses first.</div>';
        return;
    }
    
    // Store project ID and type
    const projectId = projectData.id;
    const projectType = projectData.type;
    
    // Define predefined status colors
    const statusColors = {
        'To Do': 'secondary',
        'In Progress': 'warning',
        'Review': 'info',
        'Done': 'success',
        'Backlog': 'primary',
        'Blocked': 'danger'
    };
    
    // Give a distinct color to each column based on its order if not found in predefined
    boardData.forEach((column, index) => {
        // Calculate column color based on name or index
        let columnColor = statusColors[column.name] || getDefaultColumnColor(index);
        column.color = columnColor;
        
        const columnElement = createKanbanColumn(column, projectId, projectType);
        kanbanBoard.appendChild(columnElement);
    });
}

function getDefaultColumnColor(index) {
    const colors = ['primary', 'secondary', 'success', 'danger', 'warning', 'info'];
    return colors[index % colors.length];
}

function createKanbanColumn(columnData, projectId, projectType) {
    const columnDiv = document.createElement('div');
    columnDiv.className = 'tasks-list';
    
    // Determine if the column has tasks
    const hasIssues = columnData.issues && columnData.issues.length > 0;
    
    // Determine the text for the add button based on project type
    const addButtonText = projectType === 'development' ? 'Add Issue' : 'Add Task';
    
    // Ensure text color for badge is contrasting with background
    // Use the predefined badge-soft- classes with appropriate text color
    const badgeClass = `badge bg-${columnData.color}`;
    
    columnDiv.innerHTML = `
        <div class="d-flex mb-3">
            <div class="flex-grow-1">
                <h6 class="fs-14 text-uppercase fw-semibold mb-0">
                    ${columnData.name} 
                    <small class="${badgeClass} align-bottom ms-1 totaltask-badge">
                        ${columnData.issues.length}
                    </small>
                </h6>
            </div>
            <div class="flex-shrink-0">
                <div class="dropdown card-header-dropdown">
                    <a class="text-reset dropdown-btn" href="#" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        <span class="fw-medium text-muted fs-12">Priority<i class="mdi mdi-chevron-down ms-1"></i></span>
                    </a>
                    <div class="dropdown-menu dropdown-menu-end">
                        <a class="dropdown-item sort-by-priority" href="#" data-column-id="${columnData.id}" data-sort="priority">Priority</a>
                        <a class="dropdown-item sort-by-date" href="#" data-column-id="${columnData.id}" data-sort="date">Date Added</a>
                    </div>
                </div>
            </div>
        </div>
        <div data-simplebar class="tasks-wrapper px-3 mx-n3">
            <div id="column-${columnData.id}" class="tasks" data-status-id="${columnData.id}">
                <div class="empty-column-message" style="display: ${hasIssues ? 'none' : 'block'}">
                    <i class="ri-inbox-line fs-24 mb-2 d-block"></i>
                    <p class="mb-0">No tasks in this column</p>
                    <small class="text-muted">Drag tasks here or add a new one</small>
                </div>
                ${renderColumnIssues(columnData.issues, projectId, projectType)}
            </div>
        </div>
        <div class="my-3">
            <button class="btn btn-soft-info w-100 add-task-btn" 
                    data-status-id="${columnData.id}" 
                    data-status-name="${columnData.name}" 
                    data-project-id="${projectId}" 
                    data-project-type="${projectType}">
                <i class="ri-add-line align-bottom"></i> ${addButtonText}
            </button>
        </div>
    `;
    
    // Add event listener for Add Task/Issue button
    columnDiv.querySelector('.add-task-btn').addEventListener('click', function() {
        const statusId = this.dataset.statusId;
        const statusName = this.dataset.statusName;
        const projectId = this.dataset.projectId;
        const projectType = this.dataset.projectType;
        
        // Show the appropriate modal based on project type
        if (projectType === 'development') {
            showIssueCreationModal(statusId, statusName, projectId);
        } else {
            showTaskCreationModal(statusId, statusName, projectId);
        }
    });
    
    return columnDiv;
}



function renderColumnIssues(issues, projectId, projectType) {
    if (!issues || issues.length === 0) {
        return ''; // Empty string since we already have the empty-column-message div
    }
    
    return issues.map(issue => {
        // Debug the issue object to see what data we have
        console.log(`Rendering issue ${issue.id} for ${projectType} project:`, issue);
        
        console.log(`Issue ${issue.id} category data:`, {
            category: issue.category,
            category_id: issue.category_id,
            category_name: issue.category_name
        });

        // Determine the correct view URL based on project type
        let viewUrl;
        if (projectType === 'development') {
            viewUrl = `/tasks/issues/${issue.id}`;
        } else {
            viewUrl = `/tasks/task/${projectId}/${issue.id}`;
        }

        // Handle assignee profile picture
        let assigneeAvatar = '';
        if (issue.assignee) {
            // Determine profile picture source
            let profileImage = '/static/images/users/user-dummy-img.jpg'; // Default image
            
            if (issue.assignee.profile_picture_base64) {
                // If base64 data is available, use it directly with the proper data URL format
                profileImage = `data:image/jpeg;base64,${issue.assignee.profile_picture_base64}`;
            } else if (issue.assignee.avatar) {
                // Fallback to avatar property if it exists
                profileImage = issue.assignee.avatar;
            }
            
            assigneeAvatar = `
                <div class="avatar-group">
                    <a href="javascript: void(0);" class="avatar-group-item material-shadow" 
                    data-bs-toggle="tooltip" data-bs-placement="top" 
                    title="${issue.assignee.name}">
                        <img src="${profileImage}" alt="${issue.assignee.name}" 
                            class="rounded-circle avatar-xxs">
                    </a>
                </div>
            `;
        }
        
        // Handle priority data with more careful checking
        let priorityBadge = '';
        if (issue.priority) {
            // Debug priority info
            console.log("Priority data for issue", issue.id, ":", issue.priority);
            
            // Ensure we get a valid color
            const priorityColor = getPriorityColor(issue.priority.name);
            
            // Keep the badge-soft- class as requested
            priorityBadge = `<span class="badge badge-soft-${priorityColor}">${issue.priority.name}</span>`;
        }
        
        // Format category or type badge
        let typeCategoryBadge = getTypeOrCategoryBadgeFixed(issue, projectType);

        // Calculate progress (either from the data or based on status)
        const progress = calculateProgress(issue, projectType);
        
        // Handle due date formatting with proper null checking
        const formattedDueDate = formatDate(issue.due_date) || 'No due date';
        
        // Get proper title field based on project type
        const title = issue.title || issue.summary;
        
        // Get comments and attachments count, with fallback
        const commentsCount = issue.comments_count || 0;
        const attachmentsCount = issue.attachments_count || 0;

        console.log('All issue properties:', Object.keys(issue));
        console.log('Full issue object:', issue);

        console.log('Current User ID:', window.currentUserId);
        console.log('Issue Creator ID:', issue.created_by);
        console.log('Issue Reporter ID:', issue.reporter_id);
        console.log('Current Project Lead:', window.currentProjectLead);
        console.log('Is Admin:', window.currentUserRoleId === 1);
        console.log('Is Creator:', window.currentUserId === issue.created_by);
        console.log('Is Reporter:', window.currentUserId === issue.reporter_id);
        console.log('Is Project Lead:', window.currentUserId === window.currentProjectLead);


        
        return `
        <div class="card tasks-box" data-issue-id="${issue.id}">
            <div class="card-body">
                <div class="d-flex mb-2">
                    <h6 class="fs-15 mb-0 flex-grow-1 text-truncate task-title">
                        <a href="${viewUrl}" class="d-block text-primary">
                            ${title}
                        </a>
                    </h6>
                    <div class="dropdown">
                        <a href="javascript:void(0);" class="text-muted" data-bs-toggle="dropdown">
                            <i class="ri-more-fill"></i>
                        </a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="${viewUrl}"><i class="ri-eye-fill align-bottom me-2 text-muted"></i> View</a></li>
                            ${(window.currentUserRoleId === 1 || window.currentUserId === issue.created_by || window.currentUserId === issue.reporter_id || (window.currentProjectLead && window.currentUserId === window.currentProjectLead)) ? 
                            `<li><a class="dropdown-item edit-task" href="#" data-task-id="${issue.id}"><i class="ri-edit-2-line align-bottom me-2 text-muted"></i> Edit</a></li>
                            <li><a class="dropdown-item delete-task" href="#" data-task-id="${issue.id}"><i class="ri-delete-bin-5-line align-bottom me-2 text-muted"></i> Delete</a></li>` 
                            : ''}
                        </ul>
                    </div>
                </div>
                <p class="text-muted">${issue.description || 'No description provided'}</p>
                <div class="d-flex align-items-center">
                    <div class="flex-grow-1">
                        ${priorityBadge}
                        ${typeCategoryBadge}
                    </div>
                    <div class="flex-shrink-0">
                        ${assigneeAvatar}
                    </div>
                </div>
            </div>
            <div class="card-footer border-top-dashed">
                <div class="d-flex">
                    <div class="flex-grow-1">
                        <span class="text-muted">
                            <i class="ri-time-line align-bottom"></i> 
                            ${formattedDueDate}
                        </span>
                    </div>
                    <div class="flex-shrink-0">
                        <ul class="link-inline mb-0">
                            <li class="list-inline-item">
                                <a href="javascript:void(0)" class="text-muted"><i class="ri-question-answer-line align-bottom"></i> ${issue.comments_count}</a>
                            </li>
                            <li class="list-inline-item">
                                <a href="javascript:void(0)" class="text-muted"><i class="ri-attachment-2 align-bottom"></i> ${issue.attachments_count}</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="progress progress-sm">
                <div class="progress-bar bg-${getProgressColor(progress)}" role="progressbar" style="width: ${progress}%" aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100"></div>
            </div>
        </div>
        `;
    }).join('');
}

// Function to handle issue types vs categories
function getTypeOrCategoryBadge(issue, projectType) {
    // For development projects - handle issue_type
    if (projectType === 'development') {
        // Check if issue has a type with name property
        if (issue.issue_type && issue.issue_type.name) {
            const typeColor = getIssueTypeColor(issue.issue_type.name);
            return `<span class="badge badge-soft-${typeColor} text-${typeColor} ms-1">${issue.issue_type.name}</span>`;
        } else if (issue.type && issue.type.name) {
            const typeColor = getIssueTypeColor(issue.type.name);
            return `<span class="badge badge-soft-${typeColor} text-${typeColor} ms-1">${issue.type.name}</span>`;
        } else if (issue.type_name) {
            // If the API returns type name directly
            const typeColor = getIssueTypeColor(issue.type_name);
            return `<span class="badge badge-soft-${typeColor} text-${typeColor} ms-1">${issue.type_name}</span>`;
        } else if (issue.issue_type_name) {
            // Another possible property name
            const typeColor = getIssueTypeColor(issue.issue_type_name);
            return `<span class="badge badge-soft-${typeColor} text-${typeColor} ms-1">${issue.issue_type_name}</span>`;
        } else {
            return ''; // No type information available
        }
    }
    // For general projects - handle category
    else {
        console.log("Category data:", issue.category);
        if (issue.category && issue.category.name) {
            // Use a different color for category than priority
            const categoryColor = getCategoryColor(issue.category.name);
            return `<span class="badge badge-soft-${categoryColor} text-${categoryColor} ms-1">${issue.category.name}</span>`;
        } else if (issue.category_name) {
            // If the API returns category name directly
            const categoryColor = getCategoryColor(issue.category_name);
            return `<span class="badge badge-soft-${categoryColor} text-${categoryColor} ms-1">${issue.category_name}</span>`;
        }
        return '';
    }
}


function formatDate(dateString) {
    if (!dateString) return null;
    
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return dateString;
    
    const options = { year: 'numeric', month: 'short', day: 'numeric' };
    return date.toLocaleDateString('en-US', options);
}

function getPriorityColor(priorityName) {
    if (!priorityName) return 'secondary';
    
    const normalizedName = priorityName.toLowerCase();
    
    if (normalizedName.includes('highest') || normalizedName.includes('critical')) {
        return 'danger';
    } else if (normalizedName.includes('high') || normalizedName.includes('urgent')) {
        return 'warning';
    } else if (normalizedName.includes('medium') || normalizedName.includes('normal')) {
        return 'info';
    } else if (normalizedName.includes('low') || normalizedName.includes('optional')) {
        return 'success';
    } else if (normalizedName.includes('lowest')) {
        return 'secondary';
    } else {
        return 'primary';
    }
}

function populateDropdowns(data) {
    const projectId = data.project.id;
    const projectType = data.project.type;
    
    console.log('Populating dropdowns with data:', data);
    
    // Populate team members for assignee dropdowns
    if (data.project && data.project.team && Array.isArray(data.project.team)) {
        // For task modal
        const taskAssigneeSelect = document.getElementById('taskAssignee');
        if (taskAssigneeSelect) {
            taskAssigneeSelect.innerHTML = '<option value="">Unassigned</option>';
            data.project.team.forEach(member => {
                taskAssigneeSelect.innerHTML += `
                    <option value="${member.id}">${member.name}</option>
                `;
            });
        }
        
        // For issue modal
        const issueAssigneeSelect = document.getElementById('issueAssignee');
        if (issueAssigneeSelect) {
            issueAssigneeSelect.innerHTML = '<option value="">Unassigned</option>';
            data.project.team.forEach(member => {
                issueAssigneeSelect.innerHTML += `
                    <option value="${member.id}">${member.name}</option>
                `;
            });
        }
    }
    
    // Populate priorities based on project type
    if (data.priorities && Array.isArray(data.priorities) && data.priorities.length > 0) {
        if (projectType === 'development') {
            populateIssuePriorityDropdown(data.priorities);
        } else {
            populateTaskPriorityDropdown(data.priorities);
        }
    } else {
        // If no priorities in the data, fetch them
        fetchPriorities(projectId, projectType);
    }
    
    // Populate issue types for development projects
    if (projectType === 'development') {
        fetchIssueTypes(projectId);
    }
    
    // Populate category dropdown for general projects
    if (projectType === 'general' && data.categories && Array.isArray(data.categories)) {
        const categorySelect = document.getElementById('taskCategory');
        if (categorySelect) {
            categorySelect.innerHTML = '<option value="">Select Category</option>';
            data.categories.forEach(category => {
                categorySelect.innerHTML += `
                    <option value="${category.id}">${category.name}</option>
                `;
            });
        }
    }
}

function initializeDragAndDrop() {
    const containers = Array.from(document.querySelectorAll('.tasks'));
    
    if (containers.length === 0) {
        console.warn('No drag containers found');
        return;
    }
    
    // Store a reference to the project type globally
    const projectType = window.currentProjectType || 'general';
    
    // Initialize dragula with options to prevent default passive event issues
    const drake = dragula(containers, {
        moves: function (el, source, handle, sibling) {
            // Only allow drag by card-body, excluding dropdown buttons and links
            if (handle.classList.contains('dropdown') || 
                handle.closest('.dropdown') || 
                handle.tagName === 'A' || 
                handle.tagName === 'BUTTON') {
                return false;
            }
            return true;
        },
        // Add this option to prevent the passive event listener warning
        invalid: function(el, handle) {
            return false; // Don't consider any elements invalid for dragging
        }
    });
    
    // Update the dragula 'drop' event handler in initializeDragAndDrop function
    drake.on('drop', function(el, target, source, sibling) {
        const issueId = el.dataset.issueId;
        const newStatusId = target.dataset.statusId;
        const projectId = window.currentProjectId;
        
        // Hide empty column message immediately in the target column
        const emptyMessageInTarget = target.querySelector('.empty-column-message');
        if (emptyMessageInTarget) {
            emptyMessageInTarget.style.display = 'none';
        }
        
        // Check if source column is now empty
        checkEmptyColumnStatus(source);
        
        // Only update if status actually changed
        if (source.dataset.statusId !== newStatusId) {
            // Show loading indicator
            const originalContent = el.innerHTML;
            el.innerHTML = '<div class="text-center p-3"><div class="spinner-border spinner-border-sm" role="status"></div></div>';
            
            // Update status via the appropriate API based on project type
            updateItemStatus(issueId, newStatusId, projectType)
                .then(result => {
                    if (result.success) {
                        // Restore original content after success
                        el.innerHTML = originalContent;
                        
                        // Update task counts in column headers
                        updateColumnCounts();
                        
                        // Show success toast
                        showToast('Success', 'Status updated successfully', 'success');
                    } else {
                        // If failed, restore original position
                        source.appendChild(el);
                        el.innerHTML = originalContent;
                        
                        // Recheck empty column messages
                        checkEmptyColumnStatus(source);
                        checkEmptyColumnStatus(target);
                        
                        showToast('Error', result.error || 'Failed to update status', 'error');
                    }
                })
                .catch(error => {
                    // If exception, restore original position
                    source.appendChild(el);
                    el.innerHTML = originalContent;
                    
                    // Recheck empty column messages
                    checkEmptyColumnStatus(source);
                    checkEmptyColumnStatus(target);
                    
                    showToast('Error', error.message, 'error');
                    console.error('Error updating status:', error);
                });
        }
    });


    // Handle element removal - check for empty columns
    drake.on('remove', function(el, container, source) {
        checkEmptyColumnStatus(source);
    });
    
    // Check for shadow element - will affect empty status temporarily
    drake.on('shadow', function(el, container, source) {
        checkEmptyColumnStatus(container);
    });
    
    // Handle drag cancel - restore empty column message
    drake.on('cancel', function(el, container, source) {
        checkEmptyColumnStatus(source);
    });
    
    // Improve scrolling behavior
    const scroll = autoScroll([
        document.querySelector('.tasks-board')
    ], {
        margin: 30,
        maxSpeed: 6,
        scrollWhenOutside: true,
        autoScroll: function() {
            // Only scroll when drake is dragging
            return this.down && drake.dragging;
        }
    });
    
    // Initialize event listeners for task actions
    initializeTaskActionListeners();
}

// Function to check if a column is empty and show/hide empty message
function checkEmptyColumnStatus(column) {
    if (!column) return;
    
    // Count actual task cards, not other elements like empty messages
    const taskCards = Array.from(column.querySelectorAll('.tasks-box')).filter(el => !el.classList.contains('gu-transit'));
    
    // Find or create empty column message
    let emptyMessage = column.querySelector('.empty-column-message');
    if (!emptyMessage) {
        emptyMessage = document.createElement('div');
        emptyMessage.className = 'empty-column-message';
        emptyMessage.innerHTML = `
            <i class="ri-inbox-line fs-24 mb-2 d-block"></i>
            <p class="mb-0">No tasks in this column</p>
            <small class="text-muted">Drag tasks here or add a new one</small>
        `;
        column.prepend(emptyMessage);
    }
    
    // Show/hide empty message based on task count
    if (taskCards.length === 0) {
        emptyMessage.style.display = 'block';
    } else {
        emptyMessage.style.display = 'none';
    }
}

// Initialize event listeners for task actions
function initializeTaskActionListeners() {
    // Edit task click event
    document.querySelectorAll('.edit-task').forEach(button => {
        button.addEventListener('click', function(e) {
            e.preventDefault();
            const taskId = this.dataset.taskId;
            // Implement edit functionality
            console.log('Edit task:', taskId);
            // Redirect to edit page or show edit modal
        });
    });
    
    // Delete task click event
    document.querySelectorAll('.delete-task').forEach(button => {
        button.addEventListener('click', function(e) {
            e.preventDefault();
            const taskId = this.dataset.taskId;
            
            // Set the task ID on the delete button in the modal
            document.getElementById('delete-record').setAttribute('data-task-id', taskId);
            
            // Show the delete confirmation modal
            const deleteModal = new bootstrap.Modal(document.getElementById('deleteRecordModal'));
            deleteModal.show();
        });
    });
}

// Function to update item status based on project type
function updateItemStatus(itemId, newStatusId, projectType) {
    // Determine the correct API endpoint based on project type
    const apiEndpoint = projectType === 'development' 
        ? `/tasks/api/issues/${itemId}/update-status`
        : `/tasks/api/tasks/${itemId}/update-status`;
    
    return fetch(apiEndpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken() // Function to get CSRF token
        },
        body: JSON.stringify({ status_id: newStatusId })
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                throw new Error(err.error || `Failed to update status (${response.status})`);
            });
        }
        return response.json();
    });
}

function deleteTask(taskId) {
    // Get project type from window global
    const projectType = window.currentProjectType || 'general';
    
    // Determine the correct API endpoint based on project type
    const apiEndpoint = projectType === 'development' 
        ? `/tasks/api/issues/${taskId}`
        : `/tasks/api/tasks/${taskId}`;
    
    // Show loading spinner in the delete button
    const deleteButton = document.getElementById('delete-record');
    const originalButtonText = deleteButton.textContent;
    deleteButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Deleting...';
    deleteButton.disabled = true;
    
    fetch(apiEndpoint, {
        method: 'DELETE',
        headers: {
            'X-CSRFToken': getCsrfToken()
        }
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                throw new Error(err.error || `Failed to delete task (${response.status})`);
            });
        }
        return response.json();
    })
    .then(result => {
        // Close the modal
        const deleteModal = bootstrap.Modal.getInstance(document.getElementById('deleteRecordModal'));
        deleteModal.hide();
        
        if (result.success) {
            // Remove the task card from the board
            const taskCard = document.querySelector(`.tasks-box[data-issue-id="${taskId}"]`);
            if (taskCard) {
                const column = taskCard.closest('.tasks');
                taskCard.remove();
                
                // Check if column is now empty
                checkEmptyColumnStatus(column);
                
                // Update column counts
                updateColumnCounts();
            }
            
            // Show success message
            showToast('Success', 'Task deleted successfully', 'success');
        } else {
            showToast('Error', result.error || 'Failed to delete task', 'error');
        }
    })
    .catch(error => {
        console.error('Error deleting task:', error);
        showToast('Error', error.message, 'error');
    })
    .finally(() => {
        // Restore button state
        deleteButton.innerHTML = originalButtonText;
        deleteButton.disabled = false;
    });
}

// Helper function to get CSRF token from cookies
function getCsrfToken() {
    const name = 'csrf_token=';
    const decodedCookie = decodeURIComponent(document.cookie);
    const cookieArray = decodedCookie.split(';');
    
    for (let i = 0; i < cookieArray.length; i++) {
        let cookie = cookieArray[i].trim();
        if (cookie.indexOf(name) === 0) {
            return cookie.substring(name.length, cookie.length);
        }
    }
    return '';
}

function updateColumnCounts() {
    const columns = document.querySelectorAll('.tasks-list');
    columns.forEach(column => {
        const tasks = column.querySelector('.tasks').querySelectorAll('.tasks-box');
        // Only count actual task cards, not elements with gu-transit class (being dragged)
        const taskCount = Array.from(tasks).filter(task => !task.classList.contains('gu-transit')).length;
        column.querySelector('.totaltask-badge').textContent = taskCount;
    });
}

function filterTasks(searchTerm) {
    const allTasks = document.querySelectorAll('.tasks-box');
    let visibleTasksCount = {};
    
    allTasks.forEach(task => {
        const title = task.querySelector('.task-title').textContent.toLowerCase();
        const description = task.querySelector('.text-muted').textContent.toLowerCase();
        const statusId = task.closest('.tasks').dataset.statusId;
        
        // Initialize counter if not exists
        if (!visibleTasksCount[statusId]) {
            visibleTasksCount[statusId] = 0;
        }
        
        if (title.includes(searchTerm) || description.includes(searchTerm)) {
            task.style.display = '';
            visibleTasksCount[statusId]++;
        } else {
            task.style.display = 'none';
        }
    });
    
    // Update column counts to reflect filtered results
    const columns = document.querySelectorAll('.tasks-list');
    columns.forEach(column => {
        const statusId = column.querySelector('.tasks').dataset.statusId;
        const count = visibleTasksCount[statusId] || 0;
        column.querySelector('.totaltask-badge').textContent = count;
        
        // Show/hide empty column message based on visible tasks
        const tasksContainer = column.querySelector('.tasks');
        const emptyMessage = tasksContainer.querySelector('.empty-column-message');
        
        if (count === 0) {
            // Show empty message
            if (emptyMessage) {
                emptyMessage.style.display = 'block';
            }
        } else {
            // Hide empty message
            if (emptyMessage) {
                emptyMessage.style.display = 'none';
            }
        }
    });
}

function getProgressColor(progress) {
    if (progress >= 75) return 'success';
    if (progress >= 50) return 'info';
    if (progress >= 25) return 'warning';
    return 'danger';
}

// Function to create a new task
function createNewTask() {
    const formData = new FormData(document.getElementById('createTaskForm'));
    
    // Validate form inputs
    if (!validateTaskForm(formData)) {
        return;
    }
    
    // Show loading indicator
    const submitBtn = document.getElementById('createTaskForm').querySelector('button[type="submit"]');
    const originalBtnText = submitBtn.textContent;
    submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Creating...';
    submitBtn.disabled = true;
    
    fetch('/tasks/api/projects/' + formData.get('project_id') + '/tasks', {
        method: 'POST',
        body: formData,
        headers: {
            'X-CSRFToken': getCsrfToken()
        }
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(data => {
                throw new Error(data.error || `Failed to create task (${response.status})`);
            });
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            // Close modal
            const createTaskModal = bootstrap.Modal.getInstance(document.getElementById('createTaskModal'));
            createTaskModal.hide();

            // Reset form
            document.getElementById('createTaskForm').reset();
            
            // Reload board data to show new task
            loadKanbanBoardData(formData.get('project_id'));
            
            // Show success message
            showToast('Success', 'Task created successfully', 'success');
        } else {
            // Show error
            showToast('Error', result.error || 'Failed to create task', 'error');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        showToast('Error', error.message || 'An error occurred while creating the task', 'error');
    })
    .finally(() => {
        // Restore button state
        submitBtn.innerHTML = originalBtnText;
        submitBtn.disabled = false;
    });
}

// Function to create a new issue
function createNewIssue() {
    const formData = new FormData(document.getElementById('createIssueForm'));
    
    // Validate form inputs
    if (!validateIssueForm(formData)) {
        return;
    }
    
    // Show loading indicator
    const submitBtn = document.getElementById('createIssueForm').querySelector('button[type="submit"]');
    const originalBtnText = submitBtn.textContent;
    submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Creating...';
    submitBtn.disabled = true;
    
    fetch('/tasks/api/projects/' + formData.get('project_id') + '/issues', {
        method: 'POST',
        body: formData,
        headers: {
            'X-CSRFToken': getCsrfToken()
        }
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(data => {
                throw new Error(data.error || `Failed to create issue (${response.status})`);
            });
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            // Close modal
            const createIssueModal = bootstrap.Modal.getInstance(document.getElementById('createIssueModal'));
            createIssueModal.hide();

            // Reset form
            document.getElementById('createIssueForm').reset();
            
            // Reload board data to show new issue
            loadKanbanBoardData(formData.get('project_id'));
            
            // Show success message
            showToast('Success', 'Issue created successfully', 'success');
        } else {
            // Show error
            showToast('Error', result.error || 'Failed to create issue', 'error');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        showToast('Error', error.message || 'An error occurred while creating the issue', 'error');
    })
    .finally(() => {
        // Restore button state
        submitBtn.innerHTML = originalBtnText;
        submitBtn.disabled = false;
    });
}

function showToast(title, message, type = 'info') {
    // Create toast container if it doesn't exist
    let toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
        document.body.appendChild(toastContainer);
    }
    
    // Create toast element
    const toastId = 'toast-' + Date.now();
    const toast = document.createElement('div');
    toast.className = `toast align-items-center text-white bg-${type === 'success' ? 'success' : type === 'error' ? 'danger' : 'info'} border-0`;
    toast.id = toastId;
    toast.setAttribute('role', 'alert');
    toast.setAttribute('aria-live', 'assertive');
    toast.setAttribute('aria-atomic', 'true');
    
    toast.innerHTML = `
        <div class="d-flex">
            <div class="toast-body">
                <strong>${title}</strong>: ${message}
            </div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
    `;
    
    toastContainer.appendChild(toast);
    
    // Initialize and show the toast
    const toastInstance = new bootstrap.Toast(toast, { delay: 5000 });
    toastInstance.show();
    
    // Remove toast from DOM after it's hidden
    toast.addEventListener('hidden.bs.toast', function () {
        toast.remove();
    });
}

// Function to handle issue types vs categories
function getTypeOrCategoryBadgeFixed(issue, projectType) {
    // For development projects - handle issue_type
    if (projectType === 'development') {
        // Check if issue has a type with name property
        if (issue.type && issue.type.name) {
            const typeColor = getIssueTypeColor(issue.type.name);
            return `<span class="badge badge-soft-${typeColor} ms-1">${issue.type.name}</span>`;
        } else if (issue.issue_type && issue.issue_type.name) {
            const typeColor = getIssueTypeColor(issue.issue_type.name);
            return `<span class="badge badge-soft-${typeColor} ms-1">${issue.issue_type.name}</span>`;
        } else if (issue.type_name) {
            // If the API returns type name directly
            const typeColor = getIssueTypeColor(issue.type_name);
            return `<span class="badge badge-soft-${typeColor} ms-1">${issue.type_name}</span>`;
        } else if (issue.issue_type_name) {
            // Another possible property name
            const typeColor = getIssueTypeColor(issue.issue_type_name);
            return `<span class="badge badge-soft-${typeColor} ms-1">${issue.issue_type_name}</span>`;
        } else {
            console.log("No type info found for issue:", issue.id);
            return ''; // No type information available
        }
    }
    // For general projects - handle category
    else {
        // Create a placeholder element that will be updated when the API call completes
        const placeholderId = `category-badge-${issue.id}`;
        
        // Initiate API call to get category information
        if (issue.id && issue.category_id) {
            // If we already have category_id, use it directly
            fetchTaskCategory(issue.category_id, placeholderId);
        } else if (issue.id) {
            // Otherwise fetch the category using the task ID
            fetchTaskCategoryByTaskId(issue.id, placeholderId);
        }
        
        // Return a placeholder element that will be updated by the API call
        return `<span id="${placeholderId}" class="badge badge-soft-secondary ms-1">Loading...</span>`;
    }
}


function fetchTaskCategory(categoryId, placeholderId) {
    if (!categoryId) return;
    
    fetch(`/tasks/api/categories/${categoryId}`)
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to fetch category');
            }
            return response.json();
        })
        .then(data => {
            if (data.success && data.category) {
                updateCategoryBadge(placeholderId, data.category);
            } else {
                // Hide the badge if no category found
                document.getElementById(placeholderId).style.display = 'none';
            }
        })
        .catch(error => {
            console.error('Error fetching category:', error);
            // Hide the badge on error
            document.getElementById(placeholderId).style.display = 'none';
        });
}

// Function to fetch category using task ID and update the badge
function fetchTaskCategoryByTaskId(taskId, placeholderId) {
    if (!taskId) return;
    
    fetch(`/tasks/api/tasks/${taskId}/category`)
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to fetch task category');
            }
            return response.json();
        })
        .then(data => {
            if (data.success && data.category) {
                updateCategoryBadge(placeholderId, data.category);
            } else {
                // Hide the badge if no category found
                document.getElementById(placeholderId).style.display = 'none';
            }
        })
        .catch(error => {
            console.error('Error fetching task category:', error);
            // Hide the badge on error
            document.getElementById(placeholderId).style.display = 'none';
        });
}

// Function to update the badge with fetched category information
function updateCategoryBadge(placeholderId, category) {
    const badgeElement = document.getElementById(placeholderId);
    if (!badgeElement) return;
    
    if (category && category.name) {
        // Debug logging to see exactly what we're working with
        console.log(`Category data for badge ${placeholderId}:`, {
            name: category.name,
            color: category.color,
            color_type: typeof category.color
        });
        
        let categoryColor;
        
        // Handle color properly based on what we received
        if (category.color) {
            try {
                // First try to use our hex to Bootstrap color converter
                categoryColor = hexToBootstrapColor(category.color);
                console.log(`Converted color ${category.color} to Bootstrap class: ${categoryColor}`);
            } catch (e) {
                console.warn(`Error converting hex color ${category.color}:`, e);
                // Fall back to name-based color
                categoryColor = getCategoryColor(category.name);
                console.log(`Using fallback category color based on name: ${categoryColor}`);
            }
        } else {
            // No color provided, use name-based approach
            categoryColor = getCategoryColor(category.name);
            console.log(`No color provided, using name-based color: ${categoryColor}`);
        }
        
        // Update the badge with category information
        badgeElement.className = `badge badge-soft-${categoryColor} ms-1`;
        badgeElement.textContent = category.name;
    } else {
        // Hide the badge if no valid category
        badgeElement.style.display = 'none';
    }
}

// Global variable to store category information
window.categoryCache = {};
// In the loadKanbanBoardData function, after getting the project data:
window.currentProjectLead = data.project.lead_id;
// When loading categories (in populateDropdowns or elsewhere)
function cacheCategories(categories) {
    if (Array.isArray(categories)) {
        categories.forEach(category => {
            window.categoryCache[category.id] = {
                name: category.name,
                color: category.color
            };
        });
    }
}

// Use this in the function that loads categories
if (data.categories && Array.isArray(data.categories)) {
    // Cache the categories for later use
    cacheCategories(data.categories);
    
    // Continue with existing code...
    const categorySelect = document.getElementById('taskCategory');
    // ...
}

function getBadgeColorFromHex(hexColor) {
    if (!hexColor) return 'primary';
    
    // Remove # if present
    hexColor = hexColor.replace('#', '').toLowerCase();
    
    // Map of common hex values to Bootstrap color names
    const colorMap = {
        'dc3545': 'danger',   // red
        'fd7e14': 'warning',  // orange
        'ffc107': 'warning',  // yellow
        '28a745': 'success',  // green
        '17a2b8': 'info',     // cyan
        '007bff': 'primary',  // blue
        '6610f2': 'purple',   // purple
        '6f42c1': 'purple',   // indigo
        'e83e8c': 'pink',     // pink
        '343a40': 'dark',     // dark
        '6c757d': 'secondary' // gray
    };
    
    // Check for exact matches
    if (colorMap[hexColor]) {
        return colorMap[hexColor];
    }
    
    // If no exact match, try to find the closest color
    // Convert hex to RGB for comparison
    const r = parseInt(hexColor.substring(0, 2), 16);
    const g = parseInt(hexColor.substring(2, 4), 16);
    const b = parseInt(hexColor.substring(4, 6), 16);
    
    // Define RGB values for Bootstrap colors
    const bootstrapColors = {
        'danger': [220, 53, 69],     // red
        'warning': [255, 193, 7],    // yellow
        'success': [40, 167, 69],    // green
        'info': [23, 162, 184],      // cyan
        'primary': [0, 123, 255],    // blue
        'purple': [102, 16, 242],    // purple
        'dark': [52, 58, 64],        // dark
        'secondary': [108, 117, 125] // gray
    };
    
    // Find the closest color using Euclidean distance
    let minDistance = Infinity;
    let closestColor = 'primary'; // Default
    
    for (const [colorName, rgb] of Object.entries(bootstrapColors)) {
        const distance = Math.sqrt(
            Math.pow(r - rgb[0], 2) + 
            Math.pow(g - rgb[1], 2) + 
            Math.pow(b - rgb[2], 2)
        );
        
        if (distance < minDistance) {
            minDistance = distance;
            closestColor = colorName;
        }
    }
    
    return closestColor;
}

/**
 * Converts a hex color code to the nearest Bootstrap color class name
 * @param {string} hexColor - The hex color code (with or without #)
 * @return {string} - Bootstrap color class name (primary, success, danger, etc.)
 */
 function hexToBootstrapColor(hexColor) {
    if (!hexColor) return 'primary';

    // Remove `#` if present and convert to lowercase
    hexColor = hexColor.replace('#', '').toLowerCase();

    // Direct mappings of common hex values to Bootstrap color names
    const colorMap = {
        'dc3545': 'danger', // Red
        'fd7e14': 'warning', // Orange
        'ffc107': 'warning', // Yellow
        '28a745': 'success', // Green
        '17a2b8': 'info', // Cyan
        '007bff': 'primary', // Blue
        '6f42c1': 'purple', // Indigo
        'e83e8c': 'pink', // Pink
        '343a40': 'dark', // Dark
        '6c757d': 'secondary', // Gray
    };

    // If exact match exists, return the mapped Bootstrap color
    if (colorMap[hexColor]) {
        return colorMap[hexColor];
    }

    // If no direct match, try to approximate the closest Bootstrap color
    return getClosestBootstrapColor(hexColor);
}

function getClosestBootstrapColor(hexColor) {
    // Convert hex to RGB
    const r = parseInt(hexColor.substring(0, 2), 16);
    const g = parseInt(hexColor.substring(2, 4), 16);
    const b = parseInt(hexColor.substring(4, 6), 16);

    // Predefined Bootstrap colors in RGB
    const bootstrapColors = {
        'primary': [0, 123, 255],
        'secondary': [108, 117, 125],
        'success': [40, 167, 69],
        'danger': [220, 53, 69],
        'warning': [255, 193, 7],
        'info': [23, 162, 184],
        'dark': [52, 58, 64],
        'light': [248, 249, 250]
    };

    let closestColor = 'primary';
    let minDistance = Infinity;

    for (const [color, rgb] of Object.entries(bootstrapColors)) {
        const distance = Math.sqrt(
            Math.pow(r - rgb[0], 2) +
            Math.pow(g - rgb[1], 2) +
            Math.pow(b - rgb[2], 2)
        );

        if (distance < minDistance) {
            minDistance = distance;
            closestColor = color;
        }
    }

    return closestColor;
}


function calculateProgress(issue, projectType) {
    // If the issue has a progress property, use it
    if (issue.progress !== undefined && issue.progress !== null) {
        return issue.progress;
    }
    
    // Otherwise, calculate based on status
    if (projectType === 'development') {
        // Status-based progress for development projects
        if (issue.status) {
            const statusName = issue.status.name.toLowerCase();
            if (statusName.includes('done') || statusName.includes('completed')) {
                return 100;
            } else if (statusName.includes('review')) {
                return 75;
            } else if (statusName.includes('progress')) {
                return 50;
            } else if (statusName.includes('todo') || statusName.includes('to do')) {
                return 0;
            } 
            // If status ID is available, use it for estimation
            if (issue.status.id) {
                // Assume status IDs usually go from 1 to 4 (Todo, In Progress, Review, Done)
                return Math.min(100, (issue.status.id - 1) * 33);
            }
        }
    } else {
        // Status-based progress for general projects
        if (issue.status) {
            const statusName = issue.status.name.toLowerCase();
            if (statusName.includes('done') || statusName.includes('completed')) {
                return 100;
            } else if (statusName.includes('progress')) {
                return 50;
            } else if (statusName.includes('todo') || statusName.includes('to do')) {
                return 0;
            }
            
            // If status ID is available, use it for estimation
            if (issue.status.id) {
                // Convert ID to a percentage (1=0%, 2=50%, 3=100%)
                return Math.min(100, (issue.status.id - 1) * 50);
            }
        }
    }
    
    return 0; // Default to 0% if we can't determine progress
}


// Helper function to determine issue type color
function getIssueTypeColor(typeName) {
    if (!typeName) return 'secondary';
    
    const lowerTypeName = typeName.toLowerCase();
    
    if (lowerTypeName.includes('bug') || lowerTypeName.includes('defect')) {
        return 'danger';
    } else if (lowerTypeName.includes('epic') || lowerTypeName.includes('enhancement')) {
        return 'success';
    } else if (lowerTypeName.includes('task')) {
        return 'info';
    } else if (lowerTypeName.includes('story')) {
        return 'primary';
    } else if (lowerTypeName.includes('sub-task')) {
        return 'warning';
    } else {
        return 'secondary';
    }
}


// Helper function to determine category color
function getCategoryColor(categoryName) {
    if (!categoryName) return 'info';
    
    categoryName = categoryName.toLowerCase();
    
    // Assign different colors based on common category name patterns
    if (categoryName.includes('design') || categoryName.includes('ui') || categoryName.includes('ux')) {
        return 'purple';
    } else if (categoryName.includes('backend') || categoryName.includes('server') || categoryName.includes('database')) {
        return 'info';
    } else if (categoryName.includes('frontend') || categoryName.includes('client')) {
        return 'success';
    } else if (categoryName.includes('testing') || categoryName.includes('qa')) {
        return 'warning';
    } else if (categoryName.includes('documentation') || categoryName.includes('docs')) {
        return 'dark';
    } else if (categoryName.includes('bug') || categoryName.includes('issue')) {
        return 'danger';
    } else if (categoryName.includes('feature')) {
        return 'primary';
    } else if (categoryName.includes('research')) {
        return 'info';
    } else if (categoryName.includes('maintenance')) {
        return 'secondary';
    } else {
        // Based on first letter for better distribution of colors
        const firstChar = categoryName.charAt(0).toLowerCase();
        const colors = ['primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark'];
        return colors[firstChar.charCodeAt(0) % colors.length];
    }
}

// Function to reset and prepare task modal when showing it
function showTaskCreationModal(statusId, statusName, projectId) {
    // Reset the form completely
    const taskForm = document.getElementById('createTaskForm');
    taskForm.reset();
    
    // Set the project ID and status ID
    document.getElementById('taskProjectId').value = projectId;
    document.getElementById('taskStatusId').value = statusId;
    
    // Select the correct status in the dropdown if it exists
    const taskStatusSelect = document.getElementById('taskStatus');
    if (taskStatusSelect) {
        // First check if there's an option with the status ID
        let statusOption = Array.from(taskStatusSelect.options).find(opt => opt.value == statusId);
        
        if (!statusOption) {
            // If not found, create a new option
            statusOption = document.createElement('option');
            statusOption.value = statusId;
            statusOption.text = statusName;
            taskStatusSelect.appendChild(statusOption);
        }
        
        // Select the option
        taskStatusSelect.value = statusId;
    }
    
    // Ensure priorities are loaded
    if (!prioritiesLoaded('task')) {
        fetchPriorities(projectId, 'general');
    }
    
    // Show the modal
    const createTaskModal = new bootstrap.Modal(document.getElementById('createTaskModal'));
    createTaskModal.show();
}

// Function to reset and prepare issue modal when showing it
function showIssueCreationModal(statusId, statusName, projectId) {
    // Reset the form completely
    const issueForm = document.getElementById('createIssueForm');
    issueForm.reset();
    
    // Set the project ID and status ID
    document.getElementById('issueProjectId').value = projectId;
    document.getElementById('issueStatusId').value = statusId;
    
    // Select the correct status in the dropdown if it exists
    const issueStatusSelect = document.getElementById('issueStatus');
    if (issueStatusSelect) {
        // First check if there's an option with the status ID
        let statusOption = Array.from(issueStatusSelect.options).find(opt => opt.value == statusId);
        
        if (!statusOption) {
            // If not found, create a new option
            statusOption = document.createElement('option');
            statusOption.value = statusId;
            statusOption.text = statusName;
            issueStatusSelect.appendChild(statusOption);
        }
        
        // Select the option
        issueStatusSelect.value = statusId;
    }
    
    // Ensure priorities are loaded
    if (!prioritiesLoaded('issue')) {
        fetchPriorities(projectId, 'development');
    }
    
    // Ensure issue types are loaded
    if (!issueTypesLoaded()) {
        fetchIssueTypes(projectId);
    }
    
    // Show the modal
    const createIssueModal = new bootstrap.Modal(document.getElementById('createIssueModal'));
    createIssueModal.show();
}

// Helper function to check if priorities are already loaded in dropdown
function prioritiesLoaded(modalType) {
    const selectId = modalType === 'task' ? 'taskPriority' : 'issuePriority';
    const prioritySelect = document.getElementById(selectId);
    
    // Check if we have more than just the placeholder option
    return prioritySelect && prioritySelect.options.length > 1;
}

// Helper function to check if issue types are already loaded
function issueTypesLoaded() {
    const issueTypeSelect = document.getElementById('issueType');
    
    // Check if we have any options at all
    return issueTypeSelect && issueTypeSelect.options.length > 0;
}

// Function to fetch priority data
function fetchPriorities(projectId, projectType) {
    console.log(`Fetching priorities for project ${projectId} (type: ${projectType})`);
    
    // Determine the right endpoint
    const endpoint = projectType === 'development' 
        ? `/tasks/api/projects/${projectId}/issue-priorities`
        : `/tasks/api/projects/${projectId}/task-priorities`;
    
    fetch(endpoint)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch priorities (${response.status})`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success && data.priorities) {
                console.log('Successfully fetched priorities:', data.priorities);
                
                // Map returned priorities to include appropriate colors if needed
                const mappedPriorities = data.priorities.map(priority => {
                    if (!priority.color) {
                        // If no color is provided, get one based on name
                        priority.color = getPriorityColor(priority.name);
                    }
                    return priority;
                });
                
                // Populate the right dropdown based on project type
                if (projectType === 'development') {
                    populateIssuePriorityDropdown(mappedPriorities);
                } else {
                    populateTaskPriorityDropdown(mappedPriorities);
                }
            } else {
                console.warn('No priorities in API response');
                
                // Add default priorities as fallback
                const defaultPriorities = [
                    { id: 1, name: 'High', color: 'danger' },
                    { id: 2, name: 'Medium', color: 'warning' },
                    { id: 3, name: 'Low', color: 'success' }
                ];
                
                if (projectType === 'development') {
                    populateIssuePriorityDropdown(defaultPriorities);
                } else {
                    populateTaskPriorityDropdown(defaultPriorities);
                }
            }
        })
        .catch(error => {
            console.error('Error fetching priorities:', error);
            
            // Add default priorities as fallback on error
            const defaultPriorities = [
                { id: 1, name: 'High', color: 'danger' },
                { id: 2, name: 'Medium', color: 'warning' },
                { id: 3, name: 'Low', color: 'success' }
            ];
            
            if (projectType === 'development') {
                populateIssuePriorityDropdown(defaultPriorities);
            } else {
                populateTaskPriorityDropdown(defaultPriorities);
            }
        });
}

// Function to fetch issue types
function fetchIssueTypes(projectId) {
    console.log(`Fetching issue types for project ${projectId}`);
    
    fetch(`/tasks/api/projects/${projectId}/issue-types`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch issue types (${response.status})`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success && data.issue_types) {
                console.log('Successfully fetched issue types:', data.issue_types);
                populateIssueTypeDropdown(data.issue_types);
            } else {
                console.warn('No issue types in API response');
                
                // Add default issue types as fallback
                populateIssueTypeDropdown([
                    { id: 1, name: 'Epic' },
                    { id: 2, name: 'Story' },
                    { id: 3, name: 'Task' },
                    { id: 4, name: 'Bug' },
                    { id: 5, name: 'Sub-task' }
                ]);
            }
        })
        .catch(error => {
            console.error('Error fetching issue types:', error);
            
            // Add default issue types as fallback on error
            populateIssueTypeDropdown([
                { id: 1, name: 'Epic' },
                { id: 2, name: 'Story' },
                { id: 3, name: 'Task' },
                { id: 4, name: 'Bug' },
                { id: 5, name: 'Sub-task' }
            ]);
        });
}

// Function to populate task priority dropdown
function populateTaskPriorityDropdown(priorities) {
    const prioritySelect = document.getElementById('taskPriority');
    if (!prioritySelect) return;
    
    // Clear existing options except the first one
    prioritySelect.innerHTML = '<option value="">Select Priority</option>';
    
    // Add new options
    if (Array.isArray(priorities) && priorities.length > 0) {
        priorities.forEach(priority => {
            const option = document.createElement('option');
            option.value = priority.id;
            option.textContent = priority.name;
            prioritySelect.appendChild(option);
        });
    }
}

// Function to populate issue priority dropdown
function populateIssuePriorityDropdown(priorities) {
    const prioritySelect = document.getElementById('issuePriority');
    if (!prioritySelect) return;
    
    // Clear existing options except the first one
    prioritySelect.innerHTML = '<option value="">Select Priority</option>';
    
    // Add new options
    if (Array.isArray(priorities) && priorities.length > 0) {
        priorities.forEach(priority => {
            const option = document.createElement('option');
            option.value = priority.id;
            option.textContent = priority.name;
            prioritySelect.appendChild(option);
        });
    }
}

// Function to populate issue type dropdown
function populateIssueTypeDropdown(issueTypes) {
    const issueTypeSelect = document.getElementById('issueType');
    if (!issueTypeSelect) return;
    
    // Clear existing options
    issueTypeSelect.innerHTML = '';
    
    // Add new options
    if (Array.isArray(issueTypes) && issueTypes.length > 0) {
        issueTypes.forEach(type => {
            const option = document.createElement('option');
            option.value = type.id;
            option.textContent = type.name;
            issueTypeSelect.appendChild(option);
        });
        
        // Trigger change event to update dependent fields
        issueTypeSelect.dispatchEvent(new Event('change'));
    }
}

// Function to handle issue type change
function handleIssueTypeChange() {
    const issueTypeSelect = document.getElementById('issueType');
    if (!issueTypeSelect) return;
    
    const selectedType = issueTypeSelect.value;
    
    // Show/hide fields based on issue type
    const epicSelectDiv = document.getElementById('epicSelectDiv');
    const storySelectDiv = document.getElementById('storySelectDiv');
    const taskSelectDiv = document.getElementById('taskSelectDiv');
    const storyPointsDiv = document.getElementById('storyPointsDiv');
    
    // Hide all by default
    if (epicSelectDiv) epicSelectDiv.style.display = 'none';
    if (storySelectDiv) storySelectDiv.style.display = 'none';
    if (taskSelectDiv) taskSelectDiv.style.display = 'none';
    if (storyPointsDiv) storyPointsDiv.style.display = 'none';
    
    // Show relevant fields based on issue type
    switch(selectedType) {
        case '2': // Story
            if (epicSelectDiv) epicSelectDiv.style.display = 'block';
            if (storyPointsDiv) storyPointsDiv.style.display = 'block';
            break;
        case '3': // Task
            if (epicSelectDiv) epicSelectDiv.style.display = 'block';
            if (storySelectDiv) storySelectDiv.style.display = 'block';
            break;
        case '4': // Bug
            if (epicSelectDiv) epicSelectDiv.style.display = 'block';
            if (storySelectDiv) storySelectDiv.style.display = 'block';
            if (taskSelectDiv) taskSelectDiv.style.display = 'block';
            break;
        case '5': // Subtask
            if (taskSelectDiv) taskSelectDiv.style.display = 'block';
            break;
    }
}

// Form validation functions
function validateTaskForm(formData) {
    // Check title
    if (!formData.get('title')) {
        showToast('Error', 'Task title is required', 'error');
        return false;
    }
    
    // Check status
    if (!formData.get('status_id')) {
        showToast('Error', 'Status is required', 'error');
        return false;
    }
    
    return true;
}

function validateIssueForm(formData) {
    // Check summary
    if (!formData.get('summary')) {
        showToast('Error', 'Issue summary is required', 'error');
        return false;
    }
    
    // Check issue type
    if (!formData.get('issue_type_id')) {
        showToast('Error', 'Issue type is required', 'error');
        return false;
    }
    
    // Check status
    if (!formData.get('status_id')) {
        showToast('Error', 'Status is required', 'error');
        return false;
    }
    
    return true;
}

function initializeTaskActionListeners() {
    // Edit task click event
    document.querySelectorAll('.edit-task').forEach(button => {
        button.addEventListener('click', function(e) {
            e.preventDefault();
            const taskId = this.dataset.taskId;
            // Implement edit functionality
            console.log('Edit task:', taskId);
            // Redirect to edit page or show edit modal
        });
    });
    
    // Delete task click event
    document.querySelectorAll('.delete-task').forEach(button => {
        button.addEventListener('click', function(e) {
            e.preventDefault();
            const taskId = this.dataset.taskId;
            
            // Set the task ID on the delete button in the modal
            document.getElementById('delete-record').setAttribute('data-task-id', taskId);
            
            // Show the delete confirmation modal
            const deleteModal = new bootstrap.Modal(document.getElementById('deleteRecordModal'));
            deleteModal.show();
        });
    });
    
    // Sort by priority event
    document.querySelectorAll('.sort-by-priority').forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const columnId = this.dataset.columnId;
            sortColumnTasks(columnId, 'priority');
        });
    });
    
    // Sort by date event
    document.querySelectorAll('.sort-by-date').forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const columnId = this.dataset.columnId;
            sortColumnTasks(columnId, 'date');
        });
    });
}

// Function to sort tasks in a column - improved date sorting
function sortColumnTasks(columnId, sortBy) {
    const column = document.getElementById(`column-${columnId}`);
    const tasks = Array.from(column.querySelectorAll('.tasks-box'));
    
    if (tasks.length <= 1) return; // No need to sort if there's only one task
    
    // Sort the tasks
    tasks.sort((a, b) => {
        if (sortBy === 'priority') {
            // Get priority values
            const priorityA = a.querySelector('.badge')?.textContent.toLowerCase() || 'z'; // Default to lowest priority
            const priorityB = b.querySelector('.badge')?.textContent.toLowerCase() || 'z';
            
            // Priority comparison - sorting in priority order (High > Medium > Low)
            const priorityOrder = { 'highest': 0, 'high': 1, 'urgent': 1, 'critical': 1, 'medium': 2, 'normal': 2, 'low': 3, 'lowest': 4 };
            
            // Find the first matching priority word
            const getOrderValue = (text) => {
                for (const key in priorityOrder) {
                    if (text.includes(key)) return priorityOrder[key];
                }
                return 99; // Default to lowest priority if no match
            };
            
            return getOrderValue(priorityA) - getOrderValue(priorityB);
        } else if (sortBy === 'date') {
            // Try multiple methods to find date information
            
            // Method 1: Look for due date in the footer
            const getDueDate = (element) => {
                const dateText = element.querySelector('.card-footer .text-muted')?.textContent || '';
                
                // Try to extract date using common patterns
                // Pattern 1: MMM DD, YYYY (e.g., "Jan 15, 2023")
                let match = dateText.match(/([A-Za-z]{3} \d{1,2}, \d{4})/);
                if (match) return new Date(match[0]);
                
                // Pattern 2: YYYY-MM-DD (e.g., "2023-01-15")
                match = dateText.match(/(\d{4}-\d{2}-\d{2})/);
                if (match) return new Date(match[0]);
                
                // Pattern 3: DD/MM/YYYY or MM/DD/YYYY
                match = dateText.match(/(\d{1,2}\/\d{1,2}\/\d{4})/);
                if (match) {
                    // Try both US and international formats
                    const parts = match[0].split('/');
                    if (parts.length === 3) {
                        // Try MM/DD/YYYY first
                        let date = new Date(`${parts[0]}/${parts[1]}/${parts[2]}`);
                        if (!isNaN(date.getTime())) return date;
                        
                        // If that fails, try DD/MM/YYYY
                        date = new Date(`${parts[1]}/${parts[0]}/${parts[2]}`);
                        if (!isNaN(date.getTime())) return date;
                    }
                }
                
                // No valid date found
                return null;
            };
            
            const dateA = getDueDate(a);
            const dateB = getDueDate(b);
            
            // If both have valid dates, compare them (earliest first)
            if (dateA && dateB) {
                return dateA - dateB;
            }
            
            // If only one has a date, put it first
            if (dateA) return -1;
            if (dateB) return 1;
            
            // If neither has a date, keep original order
            return 0;
        }
        
        return 0;
    });
    
    // Rearrange in the DOM
    tasks.forEach(task => column.appendChild(task));
    
    // Show a toast notification
    showToast('Success', `Tasks sorted by ${sortBy === 'priority' ? 'priority' : 'due date'}`, 'success');
}

</script>


<script>
    /**
 * Enhanced Kanban Board Due Date Handling
 * 
 * This script adds proper due date handling for both tasks and issues:
 * 1. SLA-based due date calculation for tasks
 * 2. Due date formatting and display
 * 3. Project setting integrations
 */

document.addEventListener('DOMContentLoaded', function() {
    // Load project settings when project is selected
    initializeProjectSettingsHandler();
    
    // Set up due date handling for task form
    initializeTaskDueDateHandling();
    
    // Set up due date formatting for displayed cards
    initializeDueDateDisplay();
});

/**
 * Initialize project settings handler
 */
function initializeProjectSettingsHandler() {
    // This function is called when a project is loaded in the Kanban board
    window.loadProjectSettings = function(projectId) {
        if (!projectId) return;
        
        fetch(`/tasks/api/projects/${projectId}`)
            .then(response => response.json())
            .then(data => {
                // Store project settings globally
                window.projectSettings = {
                    allowDueDateAssignment: data.allow_due_date_assignment,
                    projectType: data.project_type
                };
                
                // Apply settings to modals
                applyProjectSettings();
            })
            .catch(error => {
                console.error('Error loading project settings:', error);
            });
    };
    
    // Call when project is first loaded
    if (window.currentProjectId) {
        window.loadProjectSettings(window.currentProjectId);
    }
}

/**
 * Apply project settings to both task and issue modals
 */
function applyProjectSettings() {
    if (!window.projectSettings) return;
    
    // Apply to task modal
    const taskDueDateField = document.getElementById('taskDueDate');
    const taskDueDateHelperText = document.getElementById('dueDateHelperText');
    
    if (taskDueDateField) {
        if (!window.projectSettings.allowDueDateAssignment) {
            // If manual due date assignment is not allowed, hide the input field
            taskDueDateField.style.display = 'none';
            taskDueDateField.setAttribute('disabled', 'disabled');
            
            // Create or update the read-only display
            const dueDateContainer = taskDueDateField.closest('.mb-3');
            if (dueDateContainer) {
                let readOnlyDisplay = dueDateContainer.querySelector('.due-date-readonly');
                if (!readOnlyDisplay) {
                    readOnlyDisplay = document.createElement('div');
                    readOnlyDisplay.className = 'due-date-readonly form-control-plaintext';
                    readOnlyDisplay.style.marginTop = '8px';
                    taskDueDateField.after(readOnlyDisplay);
                }
                
                // Show helper text
                if (taskDueDateHelperText) {
                    taskDueDateHelperText.textContent = 'Due date will be calculated based on category SLA';
                }
            }
        } else {
            // Manual assignment is allowed, enable the field
            taskDueDateField.style.display = 'block';
            taskDueDateField.removeAttribute('disabled');
            
            // Show helper text
            if (taskDueDateHelperText) {
                taskDueDateHelperText.textContent = 'Manually set the due date';
            }
            
            // Hide any read-only display
            const dueDateContainer = taskDueDateField.closest('.mb-3');
            if (dueDateContainer) {
                const readOnlyDisplay = dueDateContainer.querySelector('.due-date-readonly');
                if (readOnlyDisplay) {
                    readOnlyDisplay.style.display = 'none';
                }
            }
        }
    }
}

/**
 * Initialize task due date handling
 */
function initializeTaskDueDateHandling() {
    const taskCategory = document.getElementById('taskCategory');
    const taskDueDateField = document.getElementById('taskDueDate');
    
    if (!taskCategory || !taskDueDateField) return;
    
    taskCategory.addEventListener('change', function() {
        // Only calculate due date if manual assignment is not allowed
        if (window.projectSettings && !window.projectSettings.allowDueDateAssignment) {
            const categoryId = this.value;
            if (!categoryId) return;
            
            // Find or create the read-only display
            const dueDateContainer = taskDueDateField.closest('.mb-3');
            let readOnlyDisplay = dueDateContainer.querySelector('.due-date-readonly');
            if (!readOnlyDisplay) {
                readOnlyDisplay = document.createElement('div');
                readOnlyDisplay.className = 'due-date-readonly form-control-plaintext';
                readOnlyDisplay.style.marginTop = '8px';
                taskDueDateField.after(readOnlyDisplay);
            }
            
            // Show "calculating" message
            readOnlyDisplay.textContent = 'Calculating due date...';
            
            // Fetch category details to get SLA
            fetch(`/tasks/api/categories/${categoryId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.category && data.category.sla_hours) {
                        const slaHours = data.category.sla_hours;
                        const now = new Date();
                        const dueDate = new Date(now.getTime() + (slaHours * 60 * 60 * 1000));
                        
                        // Format UTC date for backend storage
                        const utcFormattedDate = dueDate.toISOString().slice(0, 19).replace('T', ' ');
                        
                        // Store for form submission
                        taskDueDateField.value = utcFormattedDate;
                        
                        // Format for display in local timezone
                        const localDisplayDate = new Intl.DateTimeFormat('en-US', {
                            weekday: 'long',
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: 'numeric',
                            hour12: true
                        }).format(dueDate);
                        
                        // Update display
                        readOnlyDisplay.innerHTML = `<strong>${localDisplayDate}</strong>`;
                        
                        // Update helper text
                        const dueDateHelperText = document.getElementById('dueDateHelperText');
                        if (dueDateHelperText) {
                            dueDateHelperText.innerHTML = `Due date calculated as <strong>${slaHours} hours</strong> from now (per category SLA)`;
                        }
                    } else {
                        // No SLA defined
                        readOnlyDisplay.textContent = 'No SLA defined for this category';
                        readOnlyDisplay.style.color = '#dc3545';
                        
                        // Update helper text
                        const dueDateHelperText = document.getElementById('dueDateHelperText');
                        if (dueDateHelperText) {
                            dueDateHelperText.textContent = 'Warning: This category has no SLA defined';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching category SLA:', error);
                    readOnlyDisplay.textContent = 'Error calculating due date';
                    readOnlyDisplay.style.color = '#dc3545';
                });
        }
    });
}

/**
 * Initialize due date display for Kanban cards
 */
function initializeDueDateDisplay() {
    // This function will be called after Kanban board is loaded
    window.formatDueDates = function() {
        // Find all due date elements in task cards
        const dueDateElements = document.querySelectorAll('.card-footer .text-muted');
        
        dueDateElements.forEach(element => {
            const text = element.textContent.trim();
            if (text.includes('due date') || text.includes('Due:')) {
                // Extract the date part
                const dateMatch = text.match(/\d{4}-\d{2}-\d{2}/);
                if (dateMatch) {
                    const dateStr = dateMatch[0];
                    const dueDate = new Date(dateStr);
                    const now = new Date();
                    
                    // Calculate days until due
                    const diffTime = dueDate - now;
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    
                    // Format the date for display
                    const formattedDate = new Intl.DateTimeFormat('en-US', { 
                        month: 'short',
                        day: 'numeric'
                    }).format(dueDate);
                    
                    // Add appropriate styling based on how close the due date is
                    let dueDateClass = '';
                    let prefix = '';
                    
                    if (diffDays < 0) {
                        dueDateClass = 'text-danger fw-bold';
                        prefix = 'Overdue: ';
                    } else if (diffDays === 0) {
                        dueDateClass = 'text-warning fw-bold';
                        prefix = 'Due today: ';
                    } else if (diffDays <= 2) {
                        dueDateClass = 'text-warning';
                        prefix = 'Due soon: ';
                    }
                    
                    // Update the element
                    element.innerHTML = element.innerHTML.replace(
                        dateStr, 
                        `<span class="${dueDateClass}">${prefix}${formattedDate}</span>`
                    );
                }
            }
        });
    };
    
    // Hook into the Kanban board rendering
    const originalRenderKanbanColumns = window.renderKanbanColumns;
    if (originalRenderKanbanColumns) {
        window.renderKanbanColumns = function(...args) {
            // Call the original function
            originalRenderKanbanColumns.apply(this, args);
            
            // Format due dates after rendering
            setTimeout(window.formatDueDates, 100);
        };
    }
}

/**
 * Format a date string for display
 */
function formatDateForDisplay(dateString) {
    if (!dateString) return '-';
    
    try {
        // Parse the date string
        const date = new Date(dateString);
        
        // Check if the date is valid
        if (isNaN(date.getTime())) {
            return dateString;
        }
        
        // Format the date
        return new Intl.DateTimeFormat('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        }).format(date);
    } catch (e) {
        console.error('Error formatting date:', e);
        return dateString;
    }
}

/**
 * Enhanced Kanban Board Task Form Handling
 * 
 * This script improves task creation in the Kanban board:
 * 1. Form validation and error handling
 * 2. Better task submission with attachment support
 * 3. Category-based assignee selection
 * 4. Dynamic form field updates
 */

 document.addEventListener('DOMContentLoaded', function() {
    // Set up the task form submission handler
    initializeTaskFormHandler();
    
    // Add validation to the task form
    addTaskFormValidation();
});

/**
 * Initialize task form handler
 */
function initializeTaskFormHandler() {
    const createTaskForm = document.getElementById('createTaskForm');
    if (!createTaskForm) return;
    
    createTaskForm.addEventListener('submit', function(e) {
        e.preventDefault();
        
        // Validate form before submission
        if (validateTaskForm(this)) {
            submitTaskForm(this);
        }
    });
}

/**
 * Validate the task creation form
 */
function validateTaskForm(form) {
    const title = form.querySelector('#taskTitle').value.trim();
    const status = form.querySelector('#taskStatus').value;
    
    let isValid = true;
    let errorMessage = '';
    
    // Title is required
    if (!title) {
        isValid = false;
        errorMessage += 'Task title is required<br>';
        highlightInvalidField('taskTitle');
    } else {
        resetFieldValidationState('taskTitle');
    }
    
    // Status is required
    if (!status) {
        isValid = false;
        errorMessage += 'Status is required<br>';
        highlightInvalidField('taskStatus');
    } else {
        resetFieldValidationState('taskStatus');
    }
    
    // Show error message if validation failed
    if (!isValid) {
        showToast('Validation Error', errorMessage, 'error');
    }
    
    return isValid;
}

/**
 * Highlight an invalid form field
 */
function highlightInvalidField(fieldId) {
    const field = document.getElementById(fieldId);
    if (field) {
        field.classList.add('is-invalid');
        
        // Add validation feedback if not present
        let feedback = field.nextElementSibling;
        if (!feedback || !feedback.classList.contains('invalid-feedback')) {
            feedback = document.createElement('div');
            feedback.className = 'invalid-feedback';
            feedback.textContent = 'This field is required';
            field.after(feedback);
        }
    }
}

/**
 * Reset validation state for a field
 */
function resetFieldValidationState(fieldId) {
    const field = document.getElementById(fieldId);
    if (field) {
        field.classList.remove('is-invalid');
        
        // Remove any validation feedback
        const feedback = field.nextElementSibling;
        if (feedback && feedback.classList.contains('invalid-feedback')) {
            feedback.remove();
        }
    }
}

/**
 * Submit the task form with all data including attachments
 */
function submitTaskForm(form) {
    const formData = new FormData(form);
    const submitBtn = form.querySelector('[type="submit"]');
    
    // Disable the submit button and show loading state
    submitBtn.disabled = true;
    const originalBtnText = submitBtn.textContent;
    submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Creating...';
    
    // Handle special fields like due date
    const dueDateField = document.getElementById('taskDueDate');
    if (dueDateField && dueDateField.value) {
        try {
            // Ensure due date is in the correct format for the server
            const dueDate = new Date(dueDateField.value);
            if (!isNaN(dueDate.getTime())) {
                // Format with date and time
                const formattedDate = dueDate.toISOString().slice(0, 19).replace('T', ' ');
                formData.set('due_date', formattedDate);
            }
        } catch (e) {
            console.error('Error formatting due date:', e);
        }
    }
    
    // Submit the form data
    fetch(`/tasks/api/projects/${formData.get('project_id')}/tasks`, {
        method: 'POST',
        body: formData
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(data => {
                throw new Error(data.error || `Failed to create task (${response.status})`);
            });
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('createTaskModal'));
            modal.hide();

            // Reset form
            form.reset();
            const attachmentList = document.getElementById('attachmentList');
            if (attachmentList) attachmentList.innerHTML = '';
            
            // Show success message
            showToast('Success', 'Task created successfully', 'success');
            
            // Reload kanban board to show the new task
            setTimeout(() => {
                if (typeof loadKanbanBoardData === 'function') {
                    loadKanbanBoardData(formData.get('project_id'));
                }
            }, 500);
        } else {
            throw new Error(result.error || 'Failed to create task');
        }
    })
    .catch(error => {
        console.error('Error creating task:', error);
        showToast('Error', error.message || 'An error occurred while creating the task', 'error');
    })
    .finally(() => {
        // Re-enable the submit button
        submitBtn.disabled = false;
        submitBtn.textContent = originalBtnText;
    });
}

/**
 * Add validation to the task form
 */
function addTaskFormValidation() {
    // Add input event listeners for real-time validation
    const taskTitle = document.getElementById('taskTitle');
    if (taskTitle) {
        taskTitle.addEventListener('input', function() {
            if (this.value.trim()) {
                resetFieldValidationState('taskTitle');
            } else {
                highlightInvalidField('taskTitle');
            }
        });
    }
    
    // Add change event listeners for dropdowns
    const taskStatus = document.getElementById('taskStatus');
    if (taskStatus) {
        taskStatus.addEventListener('change', function() {
            if (this.value) {
                resetFieldValidationState('taskStatus');
            } else {
                highlightInvalidField('taskStatus');
            }
        });
    }
}

/**
 * Enhanced function to handle category change - updates assignee and due date
 */
 function enhancedCategoryChangeHandler() {
    const categorySelect = document.getElementById('taskCategory');
    if (!categorySelect) return;
    
    categorySelect.addEventListener('change', async function() {
        const categoryId = this.value;
        if (!categoryId) return;
        
        try {
            // Get the assignee select without modifying it yet
            const assigneeSelect = document.getElementById('taskAssignee');
            
            // Fetch category details including lead and SLA information
            const response = await fetch(`/tasks/api/categories/${categoryId}`);
            const data = await response.json();
            
            // Handle assignee auto-selection
            if (data.success && data.category) {
                // Set assignee to category lead if available
                if (data.category.lead && assigneeSelect) {
                    assigneeSelect.value = data.category.lead.id.toString();
                    console.log(`Auto-assigned to category lead: ${data.category.lead.name}`);
                }
                
                // Handle due date calculation based on project settings
                if (window.projectSettings && !window.projectSettings.allowDueDateAssignment) {
                    const slaHours = data.category.sla_hours || 24;
                    
                    // Calculate due date
                    const now = new Date();
                    const dueDate = new Date(now.getTime() + (slaHours * 60 * 60 * 1000));
                    
                    // Update hidden input
                    const dueDateField = document.getElementById('taskDueDate');
                    if (dueDateField) {
                        const formattedDate = dueDate.toISOString().slice(0, 19).replace('T', ' ');
                        dueDateField.value = formattedDate;
                    }
                    
                    // Update display if present
                    const readOnlyDisplay = document.querySelector('.due-date-readonly');
                    if (readOnlyDisplay) {
                        const localDisplayDate = new Intl.DateTimeFormat('en-US', {
                            weekday: 'long',
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: 'numeric',
                            hour12: true
                        }).format(dueDate);
                        
                        readOnlyDisplay.innerHTML = `<strong>${localDisplayDate}</strong>`;
                    }
                    
                    // Update helper text
                    const dueDateHelperText = document.getElementById('dueDateHelperText');
                    if (dueDateHelperText) {
                        dueDateHelperText.innerHTML = `Due date calculated as <strong>${slaHours} hours</strong> from now (category SLA)`;
                    }
                }
            }
        } catch (error) {
            console.error('Error handling category change:', error);
        }
    });
}


// Call the enhanced category handler after page load
document.addEventListener('DOMContentLoaded', enhancedCategoryChangeHandler);

/**
 * Kanban Board Integration Script
 * 
 * This script integrates all the enhancements and ensures they're properly
 * applied when the Kanban board loads or updates.
 */

// Store original functions to enhance them without replacement
window.originalFunctions = {
    loadKanbanBoardData: null,
    showTaskCreationModal: null,
    showIssueCreationModal: null,
    initializeDragAndDrop: null
};

document.addEventListener('DOMContentLoaded', function() {
    // Store original functions if they exist
    captureOriginalFunctions();
    
    // Enhance Kanban board loading
    enhanceKanbanBoardLoading();
    
    // Add global utility functions
    addGlobalUtilities();
    
    // Call initialize function if a project is already selected
    if (window.currentProjectId) {
        initializeEnhancedFunctionality(window.currentProjectId);
    }
});

/**
 * Capture original functions before enhancing them
 */
function captureOriginalFunctions() {
    if (typeof window.loadKanbanBoardData === 'function') {
        window.originalFunctions.loadKanbanBoardData = window.loadKanbanBoardData;
    }
    
    if (typeof window.showTaskCreationModal === 'function') {
        window.originalFunctions.showTaskCreationModal = window.showTaskCreationModal;
    }
    
    if (typeof window.showIssueCreationModal === 'function') {
        window.originalFunctions.showIssueCreationModal = window.showIssueCreationModal;
    }
    
    if (typeof window.initializeDragAndDrop === 'function') {
        window.originalFunctions.initializeDragAndDrop = window.initializeDragAndDrop;
    }
}

/**
 * Enhance Kanban board loading function
 */
function enhanceKanbanBoardLoading() {
    // Replace loadKanbanBoardData with enhanced version
    window.loadKanbanBoardData = function(projectId) {
        console.log('Enhanced loadKanbanBoardData called for project:', projectId);
        
        // Store project ID globally
        window.currentProjectId = projectId;
        
        // Call original function if it exists
        if (window.originalFunctions.loadKanbanBoardData) {
            window.originalFunctions.loadKanbanBoardData(projectId);
        } else {
            console.warn('Original loadKanbanBoardData function not found');
        }
        
        // Initialize enhanced functionality after a slight delay 
        // to ensure the board is loaded
        setTimeout(() => {
            initializeEnhancedFunctionality(projectId);
        }, 1000);
    };
    
    // Enhance showTaskCreationModal
    window.showTaskCreationModal = function(statusId, statusName, projectId) {
        console.log('Enhanced showTaskCreationModal called');
        
        // Call original function if it exists
        if (window.originalFunctions.showTaskCreationModal) {
            window.originalFunctions.showTaskCreationModal(statusId, statusName, projectId);
        } else {
            console.warn('Original showTaskCreationModal function not found');
            
            // Fallback implementation
            const taskForm = document.getElementById('createTaskForm');
            if (taskForm) {
                // Set project ID and status ID
                document.getElementById('taskProjectId').value = projectId;
                document.getElementById('taskStatusId').value = statusId;
                
                // Select the correct status in the dropdown
                const taskStatusSelect = document.getElementById('taskStatus');
                if (taskStatusSelect) {
                    // Try to find the status option
                    let statusOption = Array.from(taskStatusSelect.options).find(opt => opt.value == statusId);
                    
                    if (!statusOption) {
                        // If not found, create a new option
                        statusOption = document.createElement('option');
                        statusOption.value = statusId;
                        statusOption.text = statusName;
                        taskStatusSelect.appendChild(statusOption);
                    }
                    
                    // Select the option
                    taskStatusSelect.value = statusId;
                }
                
                // Load form data from the server
                loadTaskFormData(projectId);
                
                // Show the modal
                const createTaskModal = new bootstrap.Modal(document.getElementById('createTaskModal'));
                createTaskModal.show();
            }
        }
        
        // Apply enhanced functionality to the modal
        setTimeout(enhanceTaskModal, 300);
    };
    
    // Enhance showIssueCreationModal
    window.showIssueCreationModal = function(statusId, statusName, projectId) {
        console.log('Enhanced showIssueCreationModal called');
        
        // Call original function if it exists
        if (window.originalFunctions.showIssueCreationModal) {
            window.originalFunctions.showIssueCreationModal(statusId, statusName, projectId);
        } else {
            console.warn('Original showIssueCreationModal function not found');
            
            // Fallback implementation
            const issueForm = document.getElementById('createIssueForm');
            if (issueForm) {
                // Set project ID and status ID
                document.getElementById('issueProjectId').value = projectId;
                document.getElementById('issueStatusId').value = statusId;
                
                // Select the correct status in the dropdown
                const issueStatusSelect = document.getElementById('issueStatus');
                if (issueStatusSelect) {
                    // Try to find the status option
                    let statusOption = Array.from(issueStatusSelect.options).find(opt => opt.value == statusId);
                    
                    if (!statusOption) {
                        // If not found, create a new option
                        statusOption = document.createElement('option');
                        statusOption.value = statusId;
                        statusOption.text = statusName;
                        issueStatusSelect.appendChild(statusOption);
                    }
                    
                    // Select the option
                    issueStatusSelect.value = statusId;
                }
                
                // Load form data from the server
                loadIssueFormData(projectId);
                
                // Show the modal
                const createIssueModal = new bootstrap.Modal(document.getElementById('createIssueModal'));
                createIssueModal.show();
            }
        }
        
        // Apply enhanced functionality to the modal
        setTimeout(enhanceIssueModal, 300);
    };
}

/**
 * Initialize enhanced functionality for the Kanban board
 */
function initializeEnhancedFunctionality(projectId) {
    console.log('Initializing enhanced functionality for project:', projectId);
    
    // Load project settings
    if (typeof window.loadProjectSettings === 'function') {
        window.loadProjectSettings(projectId);
    }
    
    // Format due dates in task cards
    if (typeof window.formatDueDates === 'function') {
        window.formatDueDates();
    }
    
    // Initialize category-assignee relationship handling
    if (typeof initializeCategoryLeadAutoAssign === 'function') {
        initializeCategoryLeadAutoAssign();
    }
    
    // Initialize file attachment handling
    if (typeof initializeTaskAttachments === 'function') {
        initializeTaskAttachments();
    }
    
    if (typeof initializeIssueAttachments === 'function') {
        initializeIssueAttachments();
    }
    
    // Add card hover effects for better UX
    addCardHoverEffects();
}

/**
 * Add card hover effects for better UX
 */
function addCardHoverEffects() {
    // Select all kanban cards
    const cards = document.querySelectorAll('.tasks-box');
    
    cards.forEach(card => {
        // Add hover class when mouse enters
        card.addEventListener('mouseenter', function() {
            this.classList.add('shadow-sm');
            this.style.transform = 'translateY(-2px)';
            this.style.transition = 'transform 0.2s ease-out, box-shadow 0.2s ease-out';
        });
        
        // Remove hover class when mouse leaves
        card.addEventListener('mouseleave', function() {
            this.classList.remove('shadow-sm');
            this.style.transform = 'translateY(0)';
        });
    });
}

/**
 * Enhance task modal with additional functionality
 */
function enhanceTaskModal() {
    console.log('Enhancing task modal');
    
    // Initialize category-lead auto-assignment
    if (typeof initializeCategoryLeadAutoAssign === 'function') {
        initializeCategoryLeadAutoAssign();
    }
    
    // Initialize file attachment handling
    if (typeof initializeTaskAttachments === 'function') {
        initializeTaskAttachments();
    }
    
    // Initialize due date calculation
    if (typeof initializeDueDateCalculation === 'function') {
        initializeDueDateCalculation();
    }
}

/**
 * Enhance issue modal with additional functionality
 */
function enhanceIssueModal() {
    console.log('Enhancing issue modal');
    
    // Initialize issue type change handler
    if (typeof initializeIssueTypeHandler === 'function') {
        initializeIssueTypeHandler();
    }
    
    // Initialize issue cascading fields
    if (typeof initializeIssueCascadingFields === 'function') {
        initializeIssueCascadingFields();
    }
    
    // Initialize attachment handling
    if (typeof initializeIssueAttachments === 'function') {
        initializeIssueAttachments();
    }
}

/**
 * Load task form data from the server
 */
function loadTaskFormData(projectId) {
    if (!projectId) return;
    
    fetch(`/tasks/api/projects/${projectId}/form-data`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Populate categories dropdown
                const categorySelect = document.getElementById('taskCategory');
                if (categorySelect && data.data.categories.length > 0) {
                    categorySelect.innerHTML = '<option value="">Select Category</option>';
                    data.data.categories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category.id;
                        option.textContent = category.name;
                        // Store SLA hours as data attribute for later use
                        if (category.sla_hours) {
                            option.dataset.slaHours = category.sla_hours;
                        }
                        categorySelect.appendChild(option);
                    });
                }
                
                // Populate statuses dropdown
                const statusSelect = document.getElementById('taskStatus');
                if (statusSelect && data.data.statuses.length > 0) {
                    statusSelect.innerHTML = '<option value="">Select Status</option>';
                    data.data.statuses.forEach(status => {
                        const option = document.createElement('option');
                        option.value = status.id;
                        option.textContent = status.name;
                        statusSelect.appendChild(option);
                    });
                    
                    // Restore selected status from hidden field
                    const statusId = document.getElementById('taskStatusId').value;
                    if (statusId) {
                        statusSelect.value = statusId;
                    }
                }
                
                // Populate priorities dropdown
                const prioritySelect = document.getElementById('taskPriority');
                if (prioritySelect && data.data.priorities.length > 0) {
                    prioritySelect.innerHTML = '<option value="">Select Priority</option>';
                    data.data.priorities.forEach(priority => {
                        const option = document.createElement('option');
                        option.value = priority.id;
                        option.textContent = priority.name;
                        prioritySelect.appendChild(option);
                    });
                    
                    // Select a default priority (usually Medium or Normal - ID 3)
                    if (data.data.priorities.some(p => p.id === 3)) {
                        prioritySelect.value = '3';
                    }
                }
                
                // Populate team members dropdown
                const assigneeSelect = document.getElementById('taskAssignee');
                if (assigneeSelect && data.data.team_members.length > 0) {
                    assigneeSelect.innerHTML = '<option value="">Unassigned</option>';
                    data.data.team_members.forEach(member => {
                        const option = document.createElement('option');
                        option.value = member.id;
                        option.textContent = member.name;
                        assigneeSelect.appendChild(option);
                    });
                }
            }
        })
        .catch(error => {
            console.error('Error loading form data:', error);
        });
}

/**
 * Load issue form data from the server
 */
function loadIssueFormData(projectId) {
    if (!projectId) return;
    
    // Load issue types
    fetch(`/tasks/api/projects/${projectId}/issue-types`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const issueTypeSelect = document.getElementById('issueType');
                if (issueTypeSelect) {
                    issueTypeSelect.innerHTML = '<option value="">Select Issue Type</option>';
                    data.issue_types.forEach(type => {
                        const option = document.createElement('option');
                        option.value = type.id;
                        option.textContent = type.name;
                        issueTypeSelect.appendChild(option);
                    });
                    
                    // Default to Task type (ID 3)
                    if (data.issue_types.some(t => t.id === 3)) {
                        issueTypeSelect.value = '3';
                        
                        // Trigger change event to update dependent fields
                        const event = new Event('change');
                        issueTypeSelect.dispatchEvent(event);
                    }
                }
            }
        })
        .catch(error => {
            console.error('Error loading issue types:', error);
        });
    
    // Load priorities
    fetch(`/tasks/api/projects/${projectId}/issue-priorities`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const prioritySelect = document.getElementById('issuePriority');
                if (prioritySelect) {
                    prioritySelect.innerHTML = '<option value="">Select Priority</option>';
                    data.priorities.forEach(priority => {
                        const option = document.createElement('option');
                        option.value = priority.id;
                        option.textContent = priority.name;
                        prioritySelect.appendChild(option);
                    });
                    
                    // Default to Medium priority (ID 3)
                    if (data.priorities.some(p => p.id === 3)) {
                        prioritySelect.value = '3';
                    }
                }
            }
        })
        .catch(error => {
            console.error('Error loading priorities:', error);
        });
    
    // Load statuses
    fetch(`/tasks/api/projects/${projectId}/statuses`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const statusSelect = document.getElementById('issueStatus');
                if (statusSelect) {
                    statusSelect.innerHTML = '<option value="">Select Status</option>';
                    data.statuses.forEach(status => {
                        const option = document.createElement('option');
                        option.value = status.id;
                        option.textContent = status.name;
                        statusSelect.appendChild(option);
                    });
                    
                    // Restore selected status from hidden field
                    const statusId = document.getElementById('issueStatusId').value;
                    if (statusId) {
                        statusSelect.value = statusId;
                    }
                }
            }
        })
        .catch(error => {
            console.error('Error loading statuses:', error);
        });
    
    // Load team members for assignee
    fetch(`/tasks/api/projects/${projectId}/team`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const assigneeSelect = document.getElementById('issueAssignee');
                if (assigneeSelect) {
                    assigneeSelect.innerHTML = '<option value="">Unassigned</option>';
                    data.data.forEach(member => {
                        const option = document.createElement('option');
                        option.value = member.id;
                        option.textContent = member.name;
                        assigneeSelect.appendChild(option);
                    });
                }
            }
        })
        .catch(error => {
            console.error('Error loading team members:', error);
        });
    
    // Load epics
    fetch(`/tasks/api/projects/${projectId}/epics`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const epicSelect = document.getElementById('epicId');
                if (epicSelect) {
                    epicSelect.innerHTML = '<option value="">Select Epic</option>';
                    data.epics.forEach(epic => {
                        const option = document.createElement('option');
                        option.value = epic.id;
                        option.textContent = `${epic.key}: ${epic.summary}`;
                        epicSelect.appendChild(option);
                    });
                }
            }
        })
        .catch(error => {
            console.error('Error loading epics:', error);
        });
}

/**
 * Add global utility functions
 */
function addGlobalUtilities() {
    // Toast notification function
    window.showToast = function(title, message, type = 'info') {
        // Create toast container if it doesn't exist
        let toastContainer = document.querySelector('.toast-container');
        if (!toastContainer) {
            toastContainer = document.createElement('div');
            toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
            document.body.appendChild(toastContainer);
        }
        
        // Create toast element
        const toastId = 'toast-' + Date.now();
        const toast = document.createElement('div');
        toast.className = `toast align-items-center text-white bg-${type === 'success' ? 'success' : type === 'error' ? 'danger' : 'info'} border-0`;
        toast.id = toastId;
        toast.setAttribute('role', 'alert');
        toast.setAttribute('aria-live', 'assertive');
        toast.setAttribute('aria-atomic', 'true');
        
        toast.innerHTML = `
            <div class="d-flex">
                <div class="toast-body">
                    <strong>${title}</strong>: ${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        `;
        
        toastContainer.appendChild(toast);
        
        // Initialize and show the toast
        const toastInstance = new bootstrap.Toast(toast, { delay: 5000 });
        toastInstance.show();
        
        // Remove toast from DOM after it's hidden
        toast.addEventListener('hidden.bs.toast', function () {
            toast.remove();
        });
    };
}


</script>



<script>
    /**
 * Fix for Attachment Preview Display
 * 
 * This script properly initializes the attachment handling functions that were 
 * mentioned in the integration code but weren't fully implemented.
 */

// Fix for task attachments
function initializeTaskAttachments() {
    const taskAttachments = document.getElementById('taskAttachments');
    const attachmentList = document.getElementById('attachmentList');
    
    if (!taskAttachments || !attachmentList) return;
    
    taskAttachments.addEventListener('change', function(event) {
        const files = event.target.files;
        attachmentList.innerHTML = '';
        
        Array.from(files).forEach(file => {
            const fileSize = (file.size / 1024).toFixed(2);
            const fileExtension = file.name.split('.').pop().toLowerCase();
            let iconClass = 'ri-file-text-line';
            
            // Set icon based on file type
            if (['jpg', 'jpeg', 'png', 'gif'].includes(fileExtension)) {
                iconClass = 'ri-image-line';
            } else if (['pdf'].includes(fileExtension)) {
                iconClass = 'ri-file-pdf-line';
            } else if (['doc', 'docx'].includes(fileExtension)) {
                iconClass = 'ri-file-word-line';
            } else if (['xls', 'xlsx'].includes(fileExtension)) {
                iconClass = 'ri-file-excel-line';
            }

            attachmentList.innerHTML += `
                <div class="d-flex align-items-center mt-2 border rounded p-2">
                    <i class="${iconClass} fs-20 me-2"></i>
                    <div class="flex-grow-1">
                        <div class="fw-medium">${file.name}</div>
                        <small class="text-muted">${fileSize} KB</small>
                    </div>
                    <button type="button" class="btn btn-ghost-danger btn-icon btn-sm" onclick="removeAttachment(this)">
                        <i class="ri-delete-bin-line"></i>
                    </button>
                </div>
            `;
        });
    });
}

// Modify attachment display initialization for issues
function initializeIssueAttachments() {
    const issueAttachments = document.getElementById('issueAttachments');
    const issueAttachmentList = document.getElementById('issueAttachmentList');
    
    if (!issueAttachments || !issueAttachmentList) return;
    
    // IMPORTANT: Remove all existing event listeners to prevent multiple firings
    const newIssueAttachments = issueAttachments.cloneNode(true);
    issueAttachments.parentNode.replaceChild(newIssueAttachments, issueAttachments);
    
    // Ensure attachments field is properly enabled for edits
    if (document.getElementById('createIssueForm').dataset.issueId) {
        newIssueAttachments.removeAttribute('disabled');
    }
    
    // Add a single new event listener
    newIssueAttachments.addEventListener('change', function(event) {
        console.log('Issue attachment change event fired');
        const files = event.target.files;
        
        // Don't clear existing attachments when editing
        if (!document.getElementById('createIssueForm').dataset.issueId) {
            issueAttachmentList.innerHTML = '';
        }
        
        Array.from(files).forEach(file => {
            const fileSize = (file.size / 1024).toFixed(2);
            const fileExtension = file.name.split('.').pop().toLowerCase();
            let iconClass = 'ri-file-text-line';
            
            // Set icon based on file type
            if (['jpg', 'jpeg', 'png', 'gif'].includes(fileExtension)) {
                iconClass = 'ri-image-line';
            } else if (['pdf'].includes(fileExtension)) {
                iconClass = 'ri-file-pdf-line';
            } else if (['doc', 'docx'].includes(fileExtension)) {
                iconClass = 'ri-file-word-line';
            } else if (['xls', 'xlsx'].includes(fileExtension)) {
                iconClass = 'ri-file-excel-line';
            }

            issueAttachmentList.innerHTML += `
                <div class="d-flex align-items-center mt-2 border rounded p-2">
                    <i class="${iconClass} fs-20 me-2"></i>
                    <div class="flex-grow-1">
                        <div class="fw-medium">${file.name}</div>
                        <small class="text-muted">${fileSize} KB (New)</small>
                    </div>
                    <button type="button" class="btn btn-ghost-danger btn-icon btn-sm" onclick="removeIssueAttachment(this)">
                        <i class="ri-delete-bin-line"></i>
                    </button>
                </div>
            `;
        });
    });
    
    // Similar fix for task attachments
    fixTaskAttachments();
    
    // Make this function available globally
    window.initializeIssueAttachments = initializeIssueAttachments;
}

function fixTaskAttachments() {
    const taskAttachments = document.getElementById('taskAttachments');
    const attachmentList = document.getElementById('attachmentList');
    
    if (!taskAttachments || !attachmentList) return;
    
    // Remove all existing event listeners to prevent multiple firings
    const newTaskAttachments = taskAttachments.cloneNode(true);
    taskAttachments.parentNode.replaceChild(newTaskAttachments, taskAttachments);
    
    newTaskAttachments.addEventListener('change', function(event) {
        console.log('Task attachment change event fired');
        const files = event.target.files;
        attachmentList.innerHTML = '';
        
        Array.from(files).forEach(file => {
            const fileSize = (file.size / 1024).toFixed(2);
            const fileExtension = file.name.split('.').pop().toLowerCase();
            let iconClass = 'ri-file-text-line';
            
            // Set icon based on file type
            if (['jpg', 'jpeg', 'png', 'gif'].includes(fileExtension)) {
                iconClass = 'ri-image-line';
            } else if (['pdf'].includes(fileExtension)) {
                iconClass = 'ri-file-pdf-line';
            } else if (['doc', 'docx'].includes(fileExtension)) {
                iconClass = 'ri-file-word-line';
            } else if (['xls', 'xlsx'].includes(fileExtension)) {
                iconClass = 'ri-file-excel-line';
            }

            attachmentList.innerHTML += `
                <div class="d-flex align-items-center mt-2 border rounded p-2">
                    <i class="${iconClass} fs-20 me-2"></i>
                    <div class="flex-grow-1">
                        <div class="fw-medium">${file.name}</div>
                        <small class="text-muted">${fileSize} KB</small>
                    </div>
                    <button type="button" class="btn btn-ghost-danger btn-icon btn-sm" onclick="removeAttachment(this)">
                        <i class="ri-delete-bin-line"></i>
                    </button>
                </div>
            `;
        });
    });
    
    // Update global function
    window.initializeTaskAttachments = fixTaskAttachments;
}


// Helper function to remove a task attachment
function removeAttachment(button) {
    const attachmentDiv = button.closest('.d-flex');
    attachmentDiv.remove();
    
    // Clear the file input if all attachments are removed
    if (document.getElementById('attachmentList').children.length === 0) {
        document.getElementById('taskAttachments').value = '';
    }
}

// Helper function to remove an issue attachment
function removeIssueAttachment(button) {
    const attachmentDiv = button.closest('.d-flex');
    attachmentDiv.remove();
    
    // Clear the file input if all attachments are removed
    if (document.getElementById('issueAttachmentList').children.length === 0) {
        document.getElementById('issueAttachments').value = '';
    }
}

// Add these functions to the global scope to ensure they're available
window.initializeTaskAttachments = initializeTaskAttachments;
window.initializeIssueAttachments = initializeIssueAttachments;
window.removeAttachment = removeAttachment;
window.removeIssueAttachment = removeIssueAttachment;

// Initialize attachment handling when the DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    initializeTaskAttachments();
    initializeIssueAttachments();
    
    // Since modals are loaded dynamically, also attach initialization to modal show events
    const taskModal = document.getElementById('createTaskModal');
    if (taskModal) {
        taskModal.addEventListener('shown.bs.modal', initializeTaskAttachments);
    }
    
    const issueModal = document.getElementById('createIssueModal');
    if (issueModal) {
        issueModal.addEventListener('shown.bs.modal', initializeIssueAttachments);
    }
});


/**
 * Fix for Cascading Dropdowns in Issue Form
 * 
 * This script properly initializes the cascading relationships between
 * epics, stories, and tasks in the issue creation form.
 */

/**
 * Initialize epic and story cascading selection for issues
 */
 function initializeIssueCascadingFields() {
    const epicId = document.getElementById('epicId');
    const storyId = document.getElementById('storyId');
    const parentTaskId = document.getElementById('parentTaskId');
    const issueType = document.getElementById('issueType');
    
    // If any of the required elements don't exist, exit
    if (!epicId || !storyId || !parentTaskId || !issueType) {
        console.warn('Required elements for cascading fields not found');
        return;
    }
    
    // Register initial change handling
    issueType.addEventListener('change', function() {
        console.log('Issue type changed to:', this.value);
        handleIssueTypeChange();
        
        // Pre-load parent options based on issue type
        preloadParentOptions(this.value);
    });
    
    // Epic selection changes story options
    epicId.addEventListener('change', function() {
        console.log('Epic changed to:', this.value);
        if (this.value) {
            loadStoriesForEpic(this.value);
        } else {
            // Clear story selection if no epic is selected
            storyId.innerHTML = '<option value="">Select Story</option>';
            
            // Also clear tasks since they depend on the story
            parentTaskId.innerHTML = '<option value="">Select Task</option>';
        }
    });
    
    // Story selection changes task options
    storyId.addEventListener('change', function() {
        console.log('Story changed to:', this.value);
        if (this.value) {
            loadTasksForStory(this.value);
        } else {
            // Clear task selection if no story is selected
            parentTaskId.innerHTML = '<option value="">Select Task</option>';
        }
    });
    
    // Initial call to set up the form based on current issue type
    if (issueType.value) {
        handleIssueTypeChange();
        preloadParentOptions(issueType.value);
    }
}

/**
 * Pre-load parent options based on issue type
 */
function preloadParentOptions(issueTypeId) {
    const projectId = document.getElementById('issueProjectId').value;
    if (!projectId) return;
    
    console.log('Preloading parent options for issue type:', issueTypeId);
    
    switch(issueTypeId) {
        case '2': // Story
            // Load epics for stories
            loadEpicsForProject(projectId);
            break;
            
        case '3': // Task
            // Load epics for tasks
            loadEpicsForProject(projectId);
            break;
            
        case '4': // Bug
            // Load epics for bugs
            loadEpicsForProject(projectId);
            break;
            
        case '5': // Subtask
            // Load tasks for subtasks
            loadAllTasksForProject(projectId);
            break;
    }
}

/**
 * Load epics for a project
 */
function loadEpicsForProject(projectId) {
    if (!projectId) return;
    
    const epicSelect = document.getElementById('epicId');
    if (!epicSelect) return;
    
    // Show loading state
    epicSelect.innerHTML = '<option value="">Loading epics...</option>';
    epicSelect.disabled = true;
    
    fetch(`/tasks/api/projects/${projectId}/epics`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch epics (${response.status})`);
            }
            return response.json();
        })
        .then(data => {
            // Reset the select
            epicSelect.innerHTML = '<option value="">Select Epic</option>';
            epicSelect.disabled = false;
            
            // Add epics if available
            if (data.success && data.epics && data.epics.length > 0) {
                console.log('Loaded epics:', data.epics);
                data.epics.forEach(epic => {
                    const option = document.createElement('option');
                    option.value = epic.id;
                    option.textContent = epic.key ? `${epic.key}: ${epic.summary}` : epic.summary;
                    epicSelect.appendChild(option);
                });
            } else {
                // No epics found
                epicSelect.innerHTML = '<option value="">No epics available</option>';
            }
        })
        .catch(error => {
            console.error('Error loading epics:', error);
            epicSelect.innerHTML = '<option value="">Error loading epics</option>';
            epicSelect.disabled = false;
        });
}

/**
 * Load stories for an epic
 */
function loadStoriesForEpic(epicId) {
    if (!epicId) return;
    
    const storySelect = document.getElementById('storyId');
    if (!storySelect) return;
    
    // Show loading state
    storySelect.innerHTML = '<option value="">Loading stories...</option>';
    storySelect.disabled = true;
    
    fetch(`/tasks/api/epics/${epicId}/stories`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch stories (${response.status})`);
            }
            return response.json();
        })
        .then(data => {
            // Reset the select
            storySelect.innerHTML = '<option value="">Select Story</option>';
            storySelect.disabled = false;
            
            // Add stories if available
            if (data.stories && data.stories.length > 0) {
                console.log('Loaded stories:', data.stories);
                data.stories.forEach(story => {
                    const option = document.createElement('option');
                    option.value = story.id;
                    option.textContent = story.summary;
                    storySelect.appendChild(option);
                });
            } else {
                // No stories found
                storySelect.innerHTML = '<option value="">No stories available for this epic</option>';
            }
        })
        .catch(error => {
            console.error('Error loading stories:', error);
            storySelect.innerHTML = '<option value="">Error loading stories</option>';
            storySelect.disabled = false;
        });
}

/**
 * Load tasks for a story
 */
function loadTasksForStory(storyId) {
    if (!storyId) return;
    
    const taskSelect = document.getElementById('parentTaskId');
    if (!taskSelect) return;
    
    // Show loading state
    taskSelect.innerHTML = '<option value="">Loading tasks...</option>';
    taskSelect.disabled = true;
    
    fetch(`/tasks/api/stories/${storyId}/tasks`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch tasks (${response.status})`);
            }
            return response.json();
        })
        .then(data => {
            // Reset the select
            taskSelect.innerHTML = '<option value="">Select Task</option>';
            taskSelect.disabled = false;
            
            // Add tasks if available
            if (data.tasks && data.tasks.length > 0) {
                console.log('Loaded tasks:', data.tasks);
                data.tasks.forEach(task => {
                    const option = document.createElement('option');
                    option.value = task.id;
                    option.textContent = task.summary;
                    taskSelect.appendChild(option);
                });
            } else {
                // No tasks found
                taskSelect.innerHTML = '<option value="">No tasks available for this story</option>';
            }
        })
        .catch(error => {
            console.error('Error loading tasks:', error);
            taskSelect.innerHTML = '<option value="">Error loading tasks</option>';
            taskSelect.disabled = false;
        });
}

/**
 * Load all tasks for a project (for subtask parent selection)
 */
function loadAllTasksForProject(projectId) {
    if (!projectId) return;
    
    const taskSelect = document.getElementById('parentTaskId');
    if (!taskSelect) return;
    
    // Show loading state
    taskSelect.innerHTML = '<option value="">Loading tasks...</option>';
    taskSelect.disabled = true;
    
    fetch(`/tasks/api/projects/${projectId}/all_tasks`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch tasks (${response.status})`);
            }
            return response.json();
        })
        .then(data => {
            // Reset the select
            taskSelect.innerHTML = '<option value="">Select Task</option>';
            taskSelect.disabled = false;
            
            // Add tasks if available
            if (data.success && data.tasks && data.tasks.length > 0) {
                console.log('Loaded all project tasks:', data.tasks);
                data.tasks.forEach(task => {
                    const option = document.createElement('option');
                    option.value = task.id;
                    option.textContent = task.key ? `${task.key}: ${task.summary}` : task.summary;
                    taskSelect.appendChild(option);
                });
            } else {
                // No tasks found
                taskSelect.innerHTML = '<option value="">No tasks available</option>';
            }
        })
        .catch(error => {
            console.error('Error loading all tasks:', error);
            taskSelect.innerHTML = '<option value="">Error loading tasks</option>';
            taskSelect.disabled = false;
        });
}

/**
 * Improved handler for issue type changes
 */
function handleIssueTypeChange() {
    const issueTypeSelect = document.getElementById('issueType');
    if (!issueTypeSelect) return;
    
    const selectedType = issueTypeSelect.value;
    console.log('Handling issue type change:', selectedType);
    
    // Show/hide fields based on issue type
    const epicSelectDiv = document.getElementById('epicSelectDiv');
    const storySelectDiv = document.getElementById('storySelectDiv');
    const taskSelectDiv = document.getElementById('taskSelectDiv');
    const storyPointsDiv = document.getElementById('storyPointsDiv');
    
    // Hide all by default
    if (epicSelectDiv) epicSelectDiv.style.display = 'none';
    if (storySelectDiv) storySelectDiv.style.display = 'none';
    if (taskSelectDiv) taskSelectDiv.style.display = 'none';
    if (storyPointsDiv) storyPointsDiv.style.display = 'none';
    
    // Show relevant fields based on issue type
    switch(selectedType) {
        case '1': // Epic
            // No parent relationships for epics
            break;
            
        case '2': // Story
            if (epicSelectDiv) epicSelectDiv.style.display = 'block';
            if (storyPointsDiv) storyPointsDiv.style.display = 'block';
            break;
            
        case '3': // Task
            if (epicSelectDiv) epicSelectDiv.style.display = 'block';
            if (storySelectDiv) storySelectDiv.style.display = 'block';
            break;
            
        case '4': // Bug
            if (epicSelectDiv) epicSelectDiv.style.display = 'block';
            if (storySelectDiv) storySelectDiv.style.display = 'block';
            break;
            
        case '5': // Subtask
            if (taskSelectDiv) taskSelectDiv.style.display = 'block';
            break;
    }
}

// Make functions available globally
window.initializeIssueCascadingFields = initializeIssueCascadingFields;
window.loadEpicsForProject = loadEpicsForProject;
window.loadStoriesForEpic = loadStoriesForEpic;
window.loadTasksForStory = loadTasksForStory;
window.loadAllTasksForProject = loadAllTasksForProject;
window.handleIssueTypeChange = handleIssueTypeChange;
window.preloadParentOptions = preloadParentOptions;

// Initialize cascading fields when the DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    initializeIssueCascadingFields();
    
    // Also attach initialization to modal show event
    const issueModal = document.getElementById('createIssueModal');
    if (issueModal) {
        issueModal.addEventListener('shown.bs.modal', function() {
            console.log('Issue modal shown, initializing cascading fields');
            initializeIssueCascadingFields();
            
            // If issue type is already selected, load appropriate options
            const issueType = document.getElementById('issueType');
            if (issueType && issueType.value) {
                preloadParentOptions(issueType.value);
            }
        });
    }
});



/**
 * Enhanced Integration Script for Kanban Board
 * 
 * This script ensures all the custom functions are properly initialized
 * and executed when the Kanban board loads.
 */

// Execute these fixes immediately
(function() {
    console.log('Executing Kanban board enhancements');
    
    // Store the time when fixes were applied
    window.kanbanEnhancementsLoaded = new Date();
    
    // Ensure modal elements are found
    const taskModal = document.getElementById('createTaskModal');
    const issueModal = document.getElementById('createIssueModal');
    
    if (taskModal) {
        console.log('Found task modal, setting up event handlers');
        
        // Ensure the task modal properly initializes attachments when shown
        taskModal.addEventListener('shown.bs.modal', function() {
            console.log('Task modal shown');
            if (typeof initializeTaskAttachments === 'function') {
                console.log('Initializing task attachments');
                initializeTaskAttachments();
            }
            
            if (typeof enhancedCategoryChangeHandler === 'function') {
                console.log('Setting up category change handler');
                enhancedCategoryChangeHandler();
            }
        });
    }
    
    if (issueModal) {
        console.log('Found issue modal, setting up event handlers');
        
        // Ensure the issue modal properly initializes fields when shown
        issueModal.addEventListener('shown.bs.modal', function() {
            console.log('Issue modal shown');
            
            if (typeof initializeIssueAttachments === 'function') {
                console.log('Initializing issue attachments');
                initializeIssueAttachments();
            }
            
            if (typeof initializeIssueCascadingFields === 'function') {
                console.log('Initializing issue cascading fields');
                initializeIssueCascadingFields();
                
                // If issue type is already selected, trigger a change
                const issueType = document.getElementById('issueType');
                if (issueType && issueType.value) {
                    console.log('Issue type already selected, triggering change event');
                    const event = new Event('change');
                    issueType.dispatchEvent(event);
                }
            }
        });
    }
    
    // Force initialization of commonly missing functions
    const requiredFunctions = [
        'initializeTaskAttachments',
        'initializeIssueAttachments',
        'initializeIssueCascadingFields',
        'handleIssueTypeChange',
        'removeAttachment',
        'removeIssueAttachment'
    ];
    
    // Check if any functions are missing from the global scope
    const missingFunctions = requiredFunctions.filter(func => typeof window[func] !== 'function');
    
    if (missingFunctions.length > 0) {
        console.warn('Missing required functions:', missingFunctions);
        
        // Safety backup implementations
        if (typeof window.removeAttachment !== 'function') {
            window.removeAttachment = function(button) {
                const attachmentDiv = button.closest('.d-flex');
                attachmentDiv.remove();
                const attachmentList = document.getElementById('attachmentList');
                if (attachmentList && attachmentList.children.length === 0) {
                    const taskAttachments = document.getElementById('taskAttachments');
                    if (taskAttachments) taskAttachments.value = '';
                }
            };
        }
        
        if (typeof window.removeIssueAttachment !== 'function') {
            window.removeIssueAttachment = function(button) {
                const attachmentDiv = button.closest('.d-flex');
                attachmentDiv.remove();
                const attachmentList = document.getElementById('issueAttachmentList');
                if (attachmentList && attachmentList.children.length === 0) {
                    const issueAttachments = document.getElementById('issueAttachments');
                    if (issueAttachments) issueAttachments.value = '';
                }
            };
        }
    }
    
    // Override the showTaskCreationModal function to ensure it initializes properly
    const originalShowTaskCreationModal = window.showTaskCreationModal;
    
    if (typeof originalShowTaskCreationModal === 'function') {
        window.showTaskCreationModal = function(statusId, statusName, projectId) {
            console.log('Enhanced showTaskCreationModal called');
            
            // Call the original function
            originalShowTaskCreationModal(statusId, statusName, projectId);
            
            // Add our enhancements after a slight delay to ensure the modal is shown
            setTimeout(function() {
                if (typeof initializeTaskAttachments === 'function') {
                    initializeTaskAttachments();
                }
                
                if (typeof enhancedCategoryChangeHandler === 'function') {
                    enhancedCategoryChangeHandler();
                }
            }, 300);
        };
    }
    
    // Override the showIssueCreationModal function to ensure it initializes properly
    const originalShowIssueCreationModal = window.showIssueCreationModal;
    
    if (typeof originalShowIssueCreationModal === 'function') {
        window.showIssueCreationModal = function(statusId, statusName, projectId) {
            console.log('Enhanced showIssueCreationModal called');
            
            // Call the original function
            originalShowIssueCreationModal(statusId, statusName, projectId);
            
            // Add our enhancements after a slight delay to ensure the modal is shown
            setTimeout(function() {
                if (typeof initializeIssueAttachments === 'function') {
                    initializeIssueAttachments();
                }
                
                if (typeof initializeIssueCascadingFields === 'function') {
                    initializeIssueCascadingFields();
                    
                    // Load relevant data based on the issue type
                    const issueType = document.getElementById('issueType');
                    if (issueType && issueType.value && typeof preloadParentOptions === 'function') {
                        preloadParentOptions(issueType.value);
                    }
                }
                
                if (typeof handleIssueTypeChange === 'function') {
                    handleIssueTypeChange();
                }
            }, 300);
        };
    }
    
    // Run an immediate check for the currently loaded project
    if (window.currentProjectId) {
        console.log('Project already loaded, applying enhancements for project:', window.currentProjectId);
        
        // Format any existing due dates
        if (typeof window.formatDueDates === 'function') {
            window.formatDueDates();
        }
        
        // Add card hover effects
        const cards = document.querySelectorAll('.tasks-box');
        cards.forEach(card => {
            card.addEventListener('mouseenter', function() {
                this.classList.add('shadow-sm');
                this.style.transform = 'translateY(-2px)';
                this.style.transition = 'transform 0.2s ease-out, box-shadow 0.2s ease-out';
            });
            
            card.addEventListener('mouseleave', function() {
                this.classList.remove('shadow-sm');
                this.style.transform = 'translateY(0)';
            });
        });
    }
    
    console.log('Kanban board enhancements complete');
})();


// EDIT MODAL

// Enhanced version of editTaskFromKanban function to fix status dropdown and other issues
function editTaskFromKanban(taskId) {
    isEditMode = true;
    
    // Show loading in modal title
    const modalTitle = document.querySelector('#createTaskModal .modal-title');
    const submitButton = document.getElementById('createTaskBtn');
    
    if (modalTitle) modalTitle.textContent = 'Loading Task...';
    if (submitButton) {
        submitButton.disabled = true;
        submitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading...';
    }
    
    // Show the modal first so user sees activity
    const modal = new bootstrap.Modal(document.getElementById('createTaskModal'));
    modal.show();
    
    // Fetch task details
    fetch(`/tasks/api/tasks/${taskId}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch task (${response.status})`);
            }
            return response.json();
        })
        .then(task => {
            console.log("Retrieved task data for editing:", task);
            
            // First fetch project form data to load all dropdowns
            return fetch(`/tasks/api/projects/${task.project.id}/form-data`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to fetch form data (${response.status})`);
                    }
                    return response.json();
                })
                .then(formData => {
                    // Return both task and form data
                    return { task, formData };
                });
        })
        .then(({ task, formData }) => {
            // Update modal title and button
            if (modalTitle) modalTitle.textContent = 'Edit Task';
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.textContent = 'Update Task';
            }
            
            // Populate dropdowns first
            if (formData.success) {
                // Populate statuses dropdown
                const statusSelect = document.getElementById('taskStatus');
                if (statusSelect && formData.data.statuses) {
                    statusSelect.innerHTML = '';
                    formData.data.statuses.forEach(status => {
                        const option = document.createElement('option');
                        option.value = status.id;
                        option.textContent = status.name;
                        statusSelect.appendChild(option);
                    });
                }
                
                // Populate categories dropdown
                const categorySelect = document.getElementById('taskCategory');
                if (categorySelect && formData.data.categories) {
                    categorySelect.innerHTML = '';
                    formData.data.categories.forEach(category => {
                        const option = document.createElement('option');
                        option.value = category.id;
                        option.textContent = category.name;
                        categorySelect.appendChild(option);
                    });
                }
                
                // Populate priorities dropdown
                const prioritySelect = document.getElementById('taskPriority');
                if (prioritySelect && formData.data.priorities) {
                    prioritySelect.innerHTML = '';
                    formData.data.priorities.forEach(priority => {
                        const option = document.createElement('option');
                        option.value = priority.id;
                        option.textContent = priority.name;
                        prioritySelect.appendChild(option);
                    });
                }
                
                // Populate assignees dropdown
                const assigneeSelect = document.getElementById('taskAssignee');
                if (assigneeSelect && formData.data.team_members) {
                    assigneeSelect.innerHTML = '<option value="">Unassigned</option>';
                    formData.data.team_members.forEach(member => {
                        const option = document.createElement('option');
                        option.value = member.id;
                        option.textContent = member.name;
                        assigneeSelect.appendChild(option);
                    });
                }
            }
            
            // Populate form with task data
            document.getElementById('taskProjectId').value = task.project.id;
            document.getElementById('taskTitle').value = task.title || '';
            document.getElementById('taskDescription').value = task.description || '';
            
            // Set category if exists
            const categorySelect = document.getElementById('taskCategory');
            if (categorySelect && task.category_id) {
                categorySelect.value = task.category_id;
            }
            
            // Set status if exists
            const statusSelect = document.getElementById('taskStatus');
            if (statusSelect && task.status_id) {
                statusSelect.value = task.status_id;
                console.log(`Setting status dropdown to: ${task.status_id}`);
            }
            
            // Set priority if exists
            const prioritySelect = document.getElementById('taskPriority');
            if (prioritySelect && task.priority_id) {
                prioritySelect.value = task.priority_id;
            }
            
            // Set assignee if exists
            const assigneeSelect = document.getElementById('taskAssignee');
            if (assigneeSelect && task.assignee_id) {
                assigneeSelect.value = task.assignee_id;
            }
            
            // Format due date properly if it exists
            const dueDateField = document.getElementById('taskDueDate');
            if (dueDateField && task.due_date) {
                try {
                    // Convert to date object and then to YYYY-MM-DD format for input field
                    const dueDate = new Date(task.due_date);
                    dueDateField.value = dueDate.toISOString().split('T')[0];
                } catch(e) {
                    console.error('Error formatting due date:', e);
                }
            }
            
            // Setup due date based on project settings
            setupTaskDueDateField(task);
            
            // Store task ID for update
            document.getElementById('createTaskForm').dataset.taskId = taskId;
            
            // Clear attachment list
            document.getElementById('attachmentList').innerHTML = '';
            
            // Populate attachment list if task has attachments
            if (task.attachments && task.attachments.length > 0) {
                const attachmentList = document.getElementById('attachmentList');
                
                task.attachments.forEach(attachment => {
                    attachmentList.innerHTML += `
                        <div class="d-flex align-items-center mt-2 border rounded p-2">
                            <i class="${getFileIcon(attachment.file_name)} fs-20 me-2"></i>
                            <div class="flex-grow-1">
                                <div class="fw-medium">${attachment.file_name}</div>
                                <small class="text-muted">Uploaded by ${attachment.uploaded_by}</small>
                            </div>
                            <a href="/tasks/download_attachment/${attachment.id}" class="btn btn-ghost-primary btn-icon btn-sm me-1">
                                <i class="ri-download-line"></i>
                            </a>
                        </div>
                    `;
                });
            }
        })
        .catch(error => {
            console.error('Error fetching task for edit:', error);
            
            // Update modal with error
            if (modalTitle) modalTitle.textContent = 'Error Loading Task';
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.textContent = 'Close';
            }
            
            // Show error in form
            const formContent = document.querySelector('#task-details-tab');
            if (formContent) {
                formContent.innerHTML = `
                    <div class="alert alert-danger mt-3">
                        <i class="ri-error-warning-line me-2"></i>
                        Failed to load task details: ${error.message}
                    </div>
                    <p class="text-center mt-3">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </p>
                `;
            }
        });
}

// Enhanced version of editIssueFromKanban function to fix status dropdown and related field issues
function editIssueFromKanban(issueId) {
    isEditMode = true;
    
    // Show loading in modal title
    const modalTitle = document.querySelector('#createIssueModal .modal-title');
    const submitButton = document.getElementById('createIssueBtn');
    
    if (modalTitle) modalTitle.textContent = 'Loading Issue...';
    if (submitButton) {
        submitButton.disabled = true;
        submitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading...';
    }
    
    // Show the modal first so user sees activity
    const modal = new bootstrap.Modal(document.getElementById('createIssueModal'));
    modal.show();
    
    // Fetch issue details
    fetch(`/tasks/api/issues/${issueId}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch issue (${response.status})`);
            }
            return response.json();
        })
        .then(data => {
            if (!data.success || !data.issue) {
                throw new Error('Failed to load issue details');
            }
            
            const issue = data.issue;
            const context = data.context || {};
            console.log("Retrieved issue data for editing:", issue);
            console.log("Issue context:", context);
            
            // Store the full issue data for later use
            window.currentEditIssue = issue;
            
            // Fetch all necessary data for dropdowns
            const projectId = window.currentProjectId;
            
            // Parallel fetch for all needed data
            return Promise.all([
                // Fetch statuses
                fetch(`/tasks/api/projects/${projectId}/statuses`).then(r => r.json()),
                
                // Fetch issue types
                fetch(`/tasks/api/projects/${projectId}/issue-types`).then(r => r.json()),
                
                // Fetch priorities
                fetch(`/tasks/api/projects/${projectId}/issue-priorities`).then(r => r.json()),
                
                // Fetch epics
                fetch(`/tasks/api/projects/${projectId}/epics`).then(r => r.json())
            ]).then(([statusesData, typesData, prioritiesData, epicsData]) => {
                return {
                    issue,
                    context,
                    formData: {
                        statuses: statusesData.statuses || [],
                        issueTypes: typesData.issue_types || [],
                        priorities: prioritiesData.priorities || [],
                        epics: epicsData.epics || []
                    }
                };
            });
        })
        .then(({ issue, context, formData }) => {
            // Update modal title and button
            if (modalTitle) modalTitle.textContent = 'Edit Issue';
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.textContent = 'Update Issue';
            }
            
            // Populate dropdowns first
            // Populate issue types dropdown
            const issueTypeSelect = document.getElementById('issueType');
            if (issueTypeSelect && formData.issueTypes) {
                issueTypeSelect.innerHTML = '';
                formData.issueTypes.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type.id;
                    option.textContent = type.name;
                    issueTypeSelect.appendChild(option);
                });
            }
            
            // Populate statuses dropdown
            const statusSelect = document.getElementById('issueStatus');
            if (statusSelect && formData.statuses) {
                statusSelect.innerHTML = '';
                formData.statuses.forEach(status => {
                    const option = document.createElement('option');
                    option.value = status.id;
                    option.textContent = status.name;
                    statusSelect.appendChild(option);
                });
            }
            
            // Populate priorities dropdown
            const prioritySelect = document.getElementById('issuePriority');
            if (prioritySelect && formData.priorities) {
                prioritySelect.innerHTML = '';
                formData.priorities.forEach(priority => {
                    const option = document.createElement('option');
                    option.value = priority.id;
                    option.textContent = priority.name;
                    prioritySelect.appendChild(option);
                });
            }
            
            // Populate epics dropdown
            const epicSelect = document.getElementById('epicId');
            if (epicSelect && formData.epics) {
                epicSelect.innerHTML = '<option value="">Select Epic</option>';
                formData.epics.forEach(epic => {
                    const option = document.createElement('option');
                    option.value = epic.id;
                    option.textContent = epic.key ? `${epic.key}: ${epic.summary}` : epic.summary;
                    epicSelect.appendChild(option);
                });
            }
            
            // Fetch project team for assignee dropdown
            fetch(`/tasks/api/projects/${window.currentProjectId}/team`)
                .then(response => response.json())
                .then(teamData => {
                    if (teamData.success && teamData.data) {
                        const assigneeSelect = document.getElementById('issueAssignee');
                        if (assigneeSelect) {
                            assigneeSelect.innerHTML = '<option value="">Unassigned</option>';
                            teamData.data.forEach(member => {
                                const option = document.createElement('option');
                                option.value = member.id;
                                option.textContent = member.name;
                                assigneeSelect.appendChild(option);
                            });
                            
                            // Set assignee if exists
                            if (issue.assignee && issue.assignee.id) {
                                assigneeSelect.value = issue.assignee.id;
                            }
                        }
                    }
                })
                .catch(error => console.error('Error fetching team members:', error));
            
            // Populate form with issue data
            document.getElementById('issueProjectId').value = window.currentProjectId;
            document.getElementById('issueSummary').value = issue.summary || '';
            document.getElementById('issueDescription').value = issue.description || '';
            
            // Set issue type
            if (issueTypeSelect && issue.type && issue.type.id) {
                issueTypeSelect.value = issue.type.id;
                // Trigger change event to update related fields
                issueTypeSelect.dispatchEvent(new Event('change'));
            }
            
            // Set status
            if (statusSelect && issue.status && issue.status.id) {
                statusSelect.value = issue.status.id;
                console.log(`Setting status dropdown to: ${issue.status.id}`);
            }
            
            // Set priority
            if (prioritySelect && issue.priority && issue.priority.id) {
                prioritySelect.value = issue.priority.id;
            }
            
            // Chain the loading of related fields
            loadRelationshipFields(issue, context);
            
            // Format due date properly if it exists
            const dueDateField = document.getElementById('issueDueDate');
            if (dueDateField && issue.due_date) {
                try {
                    // Convert to date object and then to YYYY-MM-DD format for input field
                    const dueDate = new Date(issue.due_date);
                    dueDateField.value = dueDate.toISOString().split('T')[0];
                } catch(e) {
                    console.error('Error formatting due date:', e);
                }
            }
            
            // Set story points if exists
            const storyPointsField = document.getElementById('storyPoints');
            if (storyPointsField && issue.story_points) {
                storyPointsField.value = issue.story_points;
            }
            
            // Set original estimate if exists
            const originalEstimateField = document.getElementById('originalEstimate');
            if (originalEstimateField && issue.original_estimate) {
                // Convert from minutes to hours
                originalEstimateField.value = (issue.original_estimate / 60).toFixed(1);
            }
            
            // Store issue ID for update
            document.getElementById('createIssueForm').dataset.issueId = issueId;
            
            // Clear attachment list
            const attachmentList = document.getElementById('issueAttachmentList');
            if (attachmentList) {
                attachmentList.innerHTML = '';
                
                // If we have attachments, display them
                if (issue.attachments && issue.attachments.length > 0) {
                    issue.attachments.forEach(attachment => {
                        attachmentList.innerHTML += `
                            <div class="d-flex align-items-center mt-2 border rounded p-2">
                                <i class="${getFileIcon(attachment.file_name)} fs-20 me-2"></i>
                                <div class="flex-grow-1">
                                    <div class="fw-medium">${attachment.file_name}</div>
                                    <small class="text-muted">Uploaded by ${attachment.uploaded_by || 'Unknown'}</small>
                                </div>
                                <a href="/tasks/download_issue_attachment/${attachment.id}" class="btn btn-ghost-primary btn-icon btn-sm me-1">
                                    <i class="ri-download-line"></i>
                                </a>
                            </div>
                        `;
                    });
                }
            }
        })
        .catch(error => {
            console.error('Error fetching issue for edit:', error);
            
            // Update modal with error
            if (modalTitle) modalTitle.textContent = 'Error Loading Issue';
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.textContent = 'Close';
            }
            
            // Show error in form
            const formContent = document.querySelector('#createIssueModal .modal-body');
            if (formContent) {
                formContent.innerHTML = `
                    <div class="alert alert-danger mt-3">
                        <i class="ri-error-warning-line me-2"></i>
                        Failed to load issue details: ${error.message}
                    </div>
                    <p class="text-center mt-3">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </p>
                `;
            }
        });
}

function loadRelationshipFields(issue, context) {
    console.log("Loading relationship fields for issue:", issue);

    // Get references to all dropdown elements
    const epicSelect = document.getElementById('epicId');
    const storySelect = document.getElementById('storyId');
    const parentTaskSelect = document.getElementById('parentTaskId');
    
    // Show all relationship fields containers initially (for debugging)
    const epicSelectDiv = document.getElementById('epicSelectDiv');
    const storySelectDiv = document.getElementById('storySelectDiv');
    const taskSelectDiv = document.getElementById('taskSelectDiv');
    
    if (epicSelectDiv) epicSelectDiv.style.display = 'block';
    if (storySelectDiv) storySelectDiv.style.display = 'block';
    if (taskSelectDiv) taskSelectDiv.style.display = 'block';

    // IMPORTANT: First, load all epics to ensure the dropdown has the current epic
    if (issue.epic_id && epicSelect) {
        console.log(`Setting epic_id: ${issue.epic_id} - direct selection`);
        
        fetch(`/tasks/api/projects/${window.currentProjectId}/epics`)
            .then(response => response.json())
            .then(data => {
                if (data.success && data.epics) {
                    // Clear and populate epic dropdown
                    epicSelect.innerHTML = '<option value="">Select Epic</option>';
                    data.epics.forEach(epic => {
                        const option = document.createElement('option');
                        option.value = epic.id;
                        option.textContent = epic.key ? `${epic.key}: ${epic.summary}` : epic.summary;
                        epicSelect.appendChild(option);
                    });
                    
                    // CRITICAL FIX: Explicitly set the epic dropdown value
                    epicSelect.value = issue.epic_id;
                    console.log(`Epic dropdown set to: ${issue.epic_id}, current value: ${epicSelect.value}`);
                    
                    // Now load stories for this epic
                    if (storySelect) {
                        loadStoriesForEpic(issue.epic_id, issue.story_id, issue.parent_id);
                    }
                }
            })
            .catch(error => console.error('Error loading epics:', error));
    }
    // If no epic but has story (direct story relationship)
    else if (issue.story_id && storySelect && !issue.epic_id) {
        console.log(`No epic, but has story_id: ${issue.story_id}`);
        
        // Add only this story to the dropdown
        storySelect.innerHTML = '<option value="">Select Story</option>';
        
        if (context.story) {
            const option = document.createElement('option');
            option.value = issue.story_id;
            option.textContent = context.story.summary || `Story #${issue.story_id}`;
            storySelect.appendChild(option);
            storySelect.value = issue.story_id;
            
            // Load tasks for this story if needed
            if (issue.parent_id && parentTaskSelect) {
                loadTasksForStory(issue.story_id, issue.parent_id);
            }
        } else {
            // Try to fetch story details
            fetch(`/tasks/api/stories/${issue.story_id}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.story) {
                        const option = document.createElement('option');
                        option.value = issue.story_id;
                        option.textContent = data.story.summary || `Story #${issue.story_id}`;
                        storySelect.appendChild(option);
                        storySelect.value = issue.story_id;
                        
                        // Load tasks for this story if needed
                        if (issue.parent_id && parentTaskSelect) {
                            loadTasksForStory(issue.story_id, issue.parent_id);
                        }
                    }
                })
                .catch(error => console.error('Error fetching story details:', error));
        }
    }
    // If only has parent task (subtask)
    else if (issue.parent_id && parentTaskSelect && !issue.story_id && !issue.epic_id) {
        console.log(`Only has parent_id: ${issue.parent_id}`);
        
        // Load all tasks for the project
        loadAllTasksForProject(window.currentProjectId, issue.parent_id);
    }
    
    // After loading the data, make sure only the appropriate fields are shown based on issue type
    setTimeout(() => {
        if (issue.type && issue.type.id) {
            showAppropriateDivsByIssueType(issue.type.id);
        }
    }, 500);
}


/**
 * Helper function to load stories for an epic with support for selection
 */
function loadStoriesForEpic(epicId, storyIdToSelect, parentIdToSelect) {
    if (!epicId) return;
    
    const storySelect = document.getElementById('storyId');
    if (!storySelect) return;
    
    // Show loading state
    storySelect.innerHTML = '<option value="">Loading stories...</option>';
    
    fetch(`/tasks/api/epics/${epicId}/stories`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch stories (${response.status})`);
            }
            return response.json();
        })
        .then(data => {
            // Reset the select
            storySelect.innerHTML = '<option value="">Select Story</option>';
            
            // Add stories if available
            if (data.stories && data.stories.length > 0) {
                console.log('Loaded stories:', data.stories);
                data.stories.forEach(story => {
                    const option = document.createElement('option');
                    option.value = story.id;
                    option.textContent = story.summary;
                    storySelect.appendChild(option);
                });
                
                // Set story if exists
                if (storyIdToSelect) {
                    console.log(`Setting story dropdown to: ${storyIdToSelect}`);
                    storySelect.value = storyIdToSelect;
                    
                    // Now load tasks for this story if there's a parent task to select
                    if (parentIdToSelect) {
                        loadTasksForStory(storyIdToSelect, parentIdToSelect);
                    }
                }
            } else {
                // No stories found
                storySelect.innerHTML = '<option value="">No stories available for this epic</option>';
            }
        })
        .catch(error => {
            console.error('Error loading stories:', error);
            storySelect.innerHTML = '<option value="">Error loading stories</option>';
        });
}

/**
 * Helper function to load tasks for a story with support for selection
 */
function loadTasksForStory(storyId, taskIdToSelect) {
    if (!storyId) return;
    
    const taskSelect = document.getElementById('parentTaskId');
    if (!taskSelect) return;
    
    // Show loading state
    taskSelect.innerHTML = '<option value="">Loading tasks...</option>';
    
    fetch(`/tasks/api/stories/${storyId}/tasks`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch tasks (${response.status})`);
            }
            return response.json();
        })
        .then(data => {
            // Reset the select
            taskSelect.innerHTML = '<option value="">Select Task</option>';
            
            // Add tasks if available
            if (data.tasks && data.tasks.length > 0) {
                console.log('Loaded tasks:', data.tasks);
                data.tasks.forEach(task => {
                    const option = document.createElement('option');
                    option.value = task.id;
                    option.textContent = task.summary;
                    taskSelect.appendChild(option);
                });
                
                // Set parent task if exists
                if (taskIdToSelect) {
                    console.log(`Setting parent task dropdown to: ${taskIdToSelect}`);
                    taskSelect.value = taskIdToSelect;
                }
            } else {
                // No tasks found
                taskSelect.innerHTML = '<option value="">No tasks available for this story</option>';
            }
        })
        .catch(error => {
            console.error('Error loading tasks:', error);
            taskSelect.innerHTML = '<option value="">Error loading tasks</option>';
        });
}

/**
 * Helper function to load all tasks for a project with support for selection
 */
function loadAllTasksForProject(projectId, taskIdToSelect) {
    if (!projectId) return;
    
    const taskSelect = document.getElementById('parentTaskId');
    if (!taskSelect) return;
    
    // Show loading state
    taskSelect.innerHTML = '<option value="">Loading tasks...</option>';
    
    fetch(`/tasks/api/projects/${projectId}/all_tasks`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch tasks (${response.status})`);
            }
            return response.json();
        })
        .then(data => {
            // Reset the select
            taskSelect.innerHTML = '<option value="">Select Task</option>';
            
            // Add tasks if available
            if (data.success && data.tasks && data.tasks.length > 0) {
                console.log('Loaded all project tasks:', data.tasks);
                data.tasks.forEach(task => {
                    const option = document.createElement('option');
                    option.value = task.id;
                    option.textContent = task.key ? `${task.key}: ${task.summary}` : task.summary;
                    taskSelect.appendChild(option);
                });
                
                // Set parent task if exists
                if (taskIdToSelect) {
                    console.log(`Setting parent task dropdown to: ${taskIdToSelect}`);
                    taskSelect.value = taskIdToSelect;
                }
            } else {
                // No tasks found
                taskSelect.innerHTML = '<option value="">No tasks available</option>';
            }
        })
        .catch(error => {
            console.error('Error loading all tasks:', error);
            taskSelect.innerHTML = '<option value="">Error loading tasks</option>';
        });
}

function showAppropriateDivsByIssueType(issueTypeId) {
    console.log("Showing appropriate divs for issue type:", issueTypeId);
    
    const epicSelectDiv = document.getElementById('epicSelectDiv');
    const storySelectDiv = document.getElementById('storySelectDiv');
    const taskSelectDiv = document.getElementById('taskSelectDiv');
    const storyPointsDiv = document.getElementById('storyPointsDiv');
    
    // Hide all by default
    if (epicSelectDiv) epicSelectDiv.style.display = 'none';
    if (storySelectDiv) storySelectDiv.style.display = 'none';
    if (taskSelectDiv) taskSelectDiv.style.display = 'none';
    if (storyPointsDiv) storyPointsDiv.style.display = 'none';
    
    // Show relevant fields based on issue type
    switch(parseInt(issueTypeId)) {
        case 1: // Epic
            // No parent relationships for epics
            break;
            
        case 2: // Story
            if (epicSelectDiv) epicSelectDiv.style.display = 'block';
            if (storyPointsDiv) storyPointsDiv.style.display = 'block';
            break;
            
        case 3: // Task
            if (epicSelectDiv) epicSelectDiv.style.display = 'block';
            if (storySelectDiv) storySelectDiv.style.display = 'block';
            break;
            
        case 4: // Bug
            if (epicSelectDiv) epicSelectDiv.style.display = 'block';
            if (storySelectDiv) storySelectDiv.style.display = 'block';
            if (taskSelectDiv) taskSelectDiv.style.display = 'block';
            break;
            
        case 5: // Subtask
            if (taskSelectDiv) taskSelectDiv.style.display = 'block';
            break;
    }
}

// Function to get icon class based on file extension
function getFileIcon(fileName) {
    if (!fileName) return 'ri-file-text-line';
    
    const ext = fileName.split('.').pop().toLowerCase();
    
    if (['jpg', 'jpeg', 'png', 'gif', 'svg'].includes(ext)) {
        return 'ri-image-line';
    } else if (ext === 'pdf') {
        return 'ri-file-pdf-line';
    } else if (['doc', 'docx'].includes(ext)) {
        return 'ri-file-word-line';
    } else if (['xls', 'xlsx'].includes(ext)) {
        return 'ri-file-excel-line';
    } else if (['ppt', 'pptx'].includes(ext)) {
        return 'ri-file-ppt-line';
    } else if (['zip', 'rar', 'tar', 'gz'].includes(ext)) {
        return 'ri-file-zip-line';
    } else {
        return 'ri-file-text-line';
    }
}

// Helper function to set up due date field based on project settings
function setupTaskDueDateField(task) {
    const dueDateField = document.getElementById('taskDueDate');
    if (!dueDateField) return;
    
    const dueDateContainer = dueDateField.closest('.mb-3');
    if (!dueDateContainer) return;
    
    // Check if we have project settings about due date assignment
    fetch(`/tasks/api/projects/${task.project.id}`)
        .then(response => response.json())
        .then(projectData => {
            if (projectData.allow_due_date_assignment) {
                // Enable manual due date editing
                dueDateField.removeAttribute('disabled');
                dueDateField.style.display = 'block';
                
                // Remove any read-only display
                const readOnlyDisplay = dueDateContainer.querySelector('.due-date-readonly');
                if (readOnlyDisplay) {
                    readOnlyDisplay.style.display = 'none';
                }
                
                // Update helper text
                const dueDateHelperText = document.getElementById('dueDateHelperText');
                if (dueDateHelperText) {
                    dueDateHelperText.textContent = 'You can modify the due date';
                }
            } else {
                // For automatic due date, show it as read-only
                dueDateField.style.display = 'none';
                dueDateField.setAttribute('disabled', 'disabled');
                
                // Create or update read-only display
                let readOnlyDisplay = dueDateContainer.querySelector('.due-date-readonly');
                if (!readOnlyDisplay) {
                    readOnlyDisplay = document.createElement('div');
                    readOnlyDisplay.className = 'due-date-readonly form-control-plaintext';
                    readOnlyDisplay.style.marginTop = '8px';
                    dueDateField.after(readOnlyDisplay);
                }
                
                // Show original due date
                if (task.due_date) {
                    const dueDate = new Date(task.due_date);
                    const displayDate = dueDate.toLocaleString('en-US', {
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        hour: 'numeric',
                        minute: 'numeric',
                        hour12: true
                    });
                    
                    readOnlyDisplay.innerHTML = `<strong>${displayDate}</strong>`;
                    
                    // Update helper text
                    const dueDateHelperText = document.getElementById('dueDateHelperText');
                    if (dueDateHelperText) {
                        dueDateHelperText.textContent = 'Due date calculated based on category SLA';
                    }
                } else {
                    readOnlyDisplay.textContent = 'No due date set';
                    
                    // Update helper text
                    const dueDateHelperText = document.getElementById('dueDateHelperText');
                    if (dueDateHelperText) {
                        dueDateHelperText.textContent = 'Due date will be calculated when task is updated';
                    }
                }
            }
        })
        .catch(error => {
            console.error('Error fetching project settings:', error);
        });
}

// Modify the task form submission handler to support updates
function modifyCreateTaskFormHandler() {
    const createTaskForm = document.getElementById('createTaskForm');
    if (!createTaskForm) return;
    
    // Remove existing event listeners by cloning and replacing
    const newForm = createTaskForm.cloneNode(true);
    createTaskForm.parentNode.replaceChild(newForm, createTaskForm);
    
    // Add our enhanced event listener
    newForm.addEventListener('submit', function(e) {
        e.preventDefault();
        
        const taskId = this.dataset.taskId;
        const isEdit = !!taskId;
        
        // Create FormData
        const formData = new FormData(this);
        
        // Set project ID if not already included
        if (!formData.has('project_id') && window.currentProjectId) {
            formData.append('project_id', window.currentProjectId);
        }
        
        // Disable submit button and show loading state
        const submitBtn = this.querySelector('button[type="submit"]');
        const originalBtnText = submitBtn.textContent;
        submitBtn.disabled = true;
        submitBtn.innerHTML = `<span class="spinner-border spinner-border-sm" role="status"></span> ${isEdit ? 'Updating...' : 'Creating...'}`;
        
        // Determine URL and method based on whether this is a create or update
        const url = isEdit 
            ? `/tasks/api/tasks/${taskId}`
            : `/tasks/api/projects/${window.currentProjectId}/tasks`;
            
        const method = isEdit ? 'PUT' : 'POST';
        
        // Send request
        fetch(url, {
            method: method,
            body: formData
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(data => {
                    throw new Error(data.error || `Failed to ${isEdit ? 'update' : 'create'} task (${response.status})`);
                });
            }
            return response.json();
        })
        .then(result => {
            if (result.success) {
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('createTaskModal'));
                modal.hide();
                
                // Reset form and clear task ID
                newForm.reset();
                delete newForm.dataset.taskId;
                
                // Show success message
                showToast('Success', `Task ${isEdit ? 'updated' : 'created'} successfully`, 'success');
                
                // Reload board data
                loadKanbanBoardData(window.currentProjectId);
            } else {
                throw new Error(result.error || `Failed to ${isEdit ? 'update' : 'create'} task`);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            showToast('Error', error.message || `An error occurred while ${isEdit ? 'updating' : 'creating'} the task`, 'error');
        })
        .finally(() => {
            // Restore button state
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalBtnText;
        });
    });
}

// Modify the issue form submission handler to support updates
function modifyCreateIssueFormHandler() {
    const createIssueForm = document.getElementById('createIssueForm');
    if (!createIssueForm) return;
    
    // Remove existing event listeners by cloning and replacing
    const newForm = createIssueForm.cloneNode(true);
    createIssueForm.parentNode.replaceChild(newForm, createIssueForm);
    
    // Add our enhanced event listener
    newForm.addEventListener('submit', function(e) {
        e.preventDefault();
        
        const issueId = this.dataset.issueId;
        const isEdit = !!issueId;
        
        // Create FormData
        const formData = new FormData(this);
        
        // Set project ID if not already included
        if (!formData.has('project_id') && window.currentProjectId) {
            formData.append('project_id', window.currentProjectId);
        }
        
        // Disable submit button and show loading state
        const submitBtn = this.querySelector('button[type="submit"]');
        const originalBtnText = submitBtn.textContent;
        submitBtn.disabled = true;
        submitBtn.innerHTML = `<span class="spinner-border spinner-border-sm" role="status"></span> ${isEdit ? 'Updating...' : 'Creating...'}`;
        
        if (isEdit) {
            // For updates, we need a two-step process:
            // 1. First update the issue data
            // 2. Then handle attachments separately if needed
            
            // Check if we have new attachments
            const hasNewAttachments = formData.getAll('attachments').some(file => file.size > 0);
            
            // Convert form data to a basic object for the initial update
            const issueData = {};
            formData.forEach((value, key) => {
                // Skip file inputs
                if (key !== 'attachments') {
                    issueData[key] = value;
                }
            });
            
            // First, update the issue data
            fetch(`/tasks/api/issues/${issueId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(issueData)
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.error || `Failed to update issue (${response.status})`);
                    });
                }
                return response.json();
            })
            .then(result => {
                if (result.success) {
                    // Issue data updated successfully
                    
                    // If there are new attachments, handle them with a separate request
                    if (hasNewAttachments) {
                        // Create a new FormData object with just the attachments
                        const attachmentFormData = new FormData();
                        
                        // Get all files from the original form
                        const files = formData.getAll('attachments');
                        files.forEach(file => {
                            if (file.size > 0) {
                                attachmentFormData.append('file', file);
                            }
                        });
                        
                        // Send the attachments to the server
                        return fetch(`/tasks/api/issues/${issueId}/attachments`, {
                            method: 'POST',
                            body: attachmentFormData
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(data => {
                                    throw new Error(data.error || `Failed to upload attachments (${response.status})`);
                                });
                            }
                            return response.json();
                        })
                        .then(attachmentResult => {
                            if (attachmentResult.success) {
                                // Both issue data and attachments updated successfully
                                return {
                                    success: true,
                                    message: 'Issue and attachments updated successfully'
                                };
                            } else {
                                throw new Error(attachmentResult.error || 'Failed to upload attachments');
                            }
                        });
                    } else {
                        // No attachments to handle
                        return result;
                    }
                } else {
                    throw new Error(result.error || 'Failed to update issue');
                }
            })
            .then(finalResult => {
                // Handle final success
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('createIssueModal'));
                modal.hide();
                
                // Reset form and clear issue ID
                newForm.reset();
                delete newForm.dataset.issueId;
                
                // Show success message
                showToast('Success', finalResult.message || 'Issue updated successfully', 'success');
                
                // Reload board data
                loadKanbanBoardData(window.currentProjectId);
            })
            .catch(error => {
                console.error('Error:', error);
                showToast('Error', error.message || 'An error occurred while updating the issue', 'error');
            })
            .finally(() => {
                // Restore button state
                submitBtn.disabled = false;
                submitBtn.innerHTML = originalBtnText;
            });
        } else {
            // For creating new issues, we can use FormData directly
            fetch(`/tasks/api/projects/${window.currentProjectId}/issues`, {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.error || `Failed to create issue (${response.status})`);
                    });
                }
                return response.json();
            })
            .then(result => {
                if (result.success) {
                    // Close modal
                    const modal = bootstrap.Modal.getInstance(document.getElementById('createIssueModal'));
                    modal.hide();
                    
                    // Reset form
                    newForm.reset();
                    
                    // Show success message
                    showToast('Success', 'Issue created successfully', 'success');
                    
                    // Reload board data
                    loadKanbanBoardData(window.currentProjectId);
                } else {
                    throw new Error(result.error || 'Failed to create issue');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showToast('Error', error.message || 'An error occurred while creating the issue', 'error');
            })
            .finally(() => {
                // Restore button state
                submitBtn.disabled = false;
                submitBtn.innerHTML = originalBtnText;
            });
        }
    });
}


function setupIssueAttachmentUpload() {
    // Make sure we're on the issue detail page or in the edit modal
    const issueAttachments = document.getElementById('issueAttachments');
    if (!issueAttachments) return;
    
    // When files are selected, show them in the preview area
    issueAttachments.addEventListener('change', function(event) {
        const files = event.target.files;
        const attachmentList = document.getElementById('issueAttachmentList');
        
        if (!attachmentList) return;
        
        // Clear existing preview for new uploads (don't clear when editing)
        if (!document.getElementById('createIssueForm').dataset.issueId) {
            attachmentList.innerHTML = '';
        }
        
        Array.from(files).forEach(file => {
            const fileSize = (file.size / 1024).toFixed(2);
            const fileExtension = file.name.split('.').pop().toLowerCase();
            let iconClass = 'ri-file-text-line';
            
            // Set icon based on file type
            if (['jpg', 'jpeg', 'png', 'gif'].includes(fileExtension)) {
                iconClass = 'ri-image-line';
            } else if (['pdf'].includes(fileExtension)) {
                iconClass = 'ri-file-pdf-line';
            } else if (['doc', 'docx'].includes(fileExtension)) {
                iconClass = 'ri-file-word-line';
            } else if (['xls', 'xlsx'].includes(fileExtension)) {
                iconClass = 'ri-file-excel-line';
            }

            attachmentList.innerHTML += `
                <div class="d-flex align-items-center mt-2 border rounded p-2">
                    <i class="${iconClass} fs-20 me-2"></i>
                    <div class="flex-grow-1">
                        <div class="fw-medium">${file.name}</div>
                        <small class="text-muted">${fileSize} KB (New)</small>
                    </div>
                    <button type="button" class="btn btn-ghost-danger btn-icon btn-sm" onclick="removeIssueAttachment(this)">
                        <i class="ri-delete-bin-line"></i>
                    </button>
                </div>
            `;
        });
    });
}

// Modify the renderColumnIssues function to connect the edit button to our edit functions
function modifyRenderColumnIssues() {
    // Store the original function
    const originalRenderColumnIssues = window.renderColumnIssues;
    
    // Replace with enhanced version
    window.renderColumnIssues = function(issues, projectId, projectType) {
        // Call the original function to get the HTML
        const html = originalRenderColumnIssues(issues, projectId, projectType);
        
        // Return the HTML - we'll attach event handlers after rendering
        return html;
    };
    
    // Add a function to attach event handlers to the edit buttons after rendering
    window.attachEditHandlers = function() {
        // For tasks in general projects
        if (window.currentProjectType === 'general') {
            document.querySelectorAll('.edit-task').forEach(button => {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    const taskId = this.dataset.taskId;
                    editTaskFromKanban(taskId);
                });
            });
        } 
        // For issues in development projects
        else if (window.currentProjectType === 'development') {
            document.querySelectorAll('.edit-task').forEach(button => {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    const issueId = this.dataset.taskId;
                    editIssueFromKanban(issueId);
                });
            });
        }
    };
    
    // Enhance the initializeDragAndDrop function to call our attachment function
    const originalInitializeDragAndDrop = window.initializeDragAndDrop;
    
    window.initializeDragAndDrop = function() {
        // Call original function
        originalInitializeDragAndDrop();
        
        // Attach our edit handlers
        window.attachEditHandlers();
    };
}

// Fix for task attachments
function fixTaskAttachments() {
    const taskAttachments = document.getElementById('taskAttachments');
    const attachmentList = document.getElementById('attachmentList');
    
    if (!taskAttachments || !attachmentList) return;
    
    // Remove all existing event listeners to prevent multiple firings
    const newTaskAttachments = taskAttachments.cloneNode(true);
    taskAttachments.parentNode.replaceChild(newTaskAttachments, taskAttachments);
    
    newTaskAttachments.addEventListener('change', function(event) {
        console.log('Task attachment change event fired');
        const files = event.target.files;
        attachmentList.innerHTML = '';
        
        Array.from(files).forEach(file => {
            const fileSize = (file.size / 1024).toFixed(2);
            const fileExtension = file.name.split('.').pop().toLowerCase();
            let iconClass = 'ri-file-text-line';
            
            // Set icon based on file type
            if (['jpg', 'jpeg', 'png', 'gif'].includes(fileExtension)) {
                iconClass = 'ri-image-line';
            } else if (['pdf'].includes(fileExtension)) {
                iconClass = 'ri-file-pdf-line';
            } else if (['doc', 'docx'].includes(fileExtension)) {
                iconClass = 'ri-file-word-line';
            } else if (['xls', 'xlsx'].includes(fileExtension)) {
                iconClass = 'ri-file-excel-line';
            }

            attachmentList.innerHTML += `
                <div class="d-flex align-items-center mt-2 border rounded p-2">
                    <i class="${iconClass} fs-20 me-2"></i>
                    <div class="flex-grow-1">
                        <div class="fw-medium">${file.name}</div>
                        <small class="text-muted">${fileSize} KB</small>
                    </div>
                    <button type="button" class="btn btn-ghost-danger btn-icon btn-sm" onclick="removeAttachment(this)">
                        <i class="ri-delete-bin-line"></i>
                    </button>
                </div>
            `;
        });
    });
    
    // Update global function
    window.initializeTaskAttachments = fixTaskAttachments;
}

// Fix for issue attachments 
function initializeIssueAttachments() {
    const issueAttachments = document.getElementById('issueAttachments');
    const issueAttachmentList = document.getElementById('issueAttachmentList');
    
    if (!issueAttachments || !issueAttachmentList) return;
    
    // IMPORTANT: Remove all existing event listeners to prevent multiple firings
    const newIssueAttachments = issueAttachments.cloneNode(true);
    issueAttachments.parentNode.replaceChild(newIssueAttachments, issueAttachments);
    
    // Ensure attachments field is properly enabled for edits
    if (document.getElementById('createIssueForm').dataset.issueId) {
        newIssueAttachments.removeAttribute('disabled');
    }
    
    // Add a single new event listener
    newIssueAttachments.addEventListener('change', function(event) {
        console.log('Issue attachment change event fired');
        const files = event.target.files;
        
        // Don't clear existing attachments when editing
        if (!document.getElementById('createIssueForm').dataset.issueId) {
            issueAttachmentList.innerHTML = '';
        }
        
        Array.from(files).forEach(file => {
            const fileSize = (file.size / 1024).toFixed(2);
            const fileExtension = file.name.split('.').pop().toLowerCase();
            let iconClass = 'ri-file-text-line';
            
            // Set icon based on file type
            if (['jpg', 'jpeg', 'png', 'gif'].includes(fileExtension)) {
                iconClass = 'ri-image-line';
            } else if (['pdf'].includes(fileExtension)) {
                iconClass = 'ri-file-pdf-line';
            } else if (['doc', 'docx'].includes(fileExtension)) {
                iconClass = 'ri-file-word-line';
            } else if (['xls', 'xlsx'].includes(fileExtension)) {
                iconClass = 'ri-file-excel-line';
            }

            issueAttachmentList.innerHTML += `
                <div class="d-flex align-items-center mt-2 border rounded p-2">
                    <i class="${iconClass} fs-20 me-2"></i>
                    <div class="flex-grow-1">
                        <div class="fw-medium">${file.name}</div>
                        <small class="text-muted">${fileSize} KB (New)</small>
                    </div>
                    <button type="button" class="btn btn-ghost-danger btn-icon btn-sm" onclick="removeIssueAttachment(this)">
                        <i class="ri-delete-bin-line"></i>
                    </button>
                </div>
            `;
        });
    });
    
    // Make this function available globally
    window.initializeIssueAttachments = initializeIssueAttachments;
}

// Helper function to remove a task attachment
function removeAttachment(button) {
    const attachmentDiv = button.closest('.d-flex');
    attachmentDiv.remove();
    
    // Clear the file input if all attachments are removed
    if (document.getElementById('attachmentList').children.length === 0) {
        document.getElementById('taskAttachments').value = '';
    }
}

// Helper function to remove an issue attachment
function removeIssueAttachment(button) {
    const attachmentDiv = button.closest('.d-flex');
    attachmentDiv.remove();
    
    // Clear the file input if all attachments are removed
    if (document.getElementById('issueAttachmentList').children.length === 0) {
        document.getElementById('issueAttachments').value = '';
    }
}

// Updated DOM ready handler to properly initialize event listeners once
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded - initializing with fixed attachment and relationship handlers');
    
    // Set up the modified issue form submission handler
    modifyCreateIssueFormHandler();
    
    // Set up the modified task form submission handler
    modifyCreateTaskFormHandler();
    
    // Initialize attachment handling once
    initializeIssueAttachments();
    fixTaskAttachments();
    
    // Expose edit functions globally for direct calls
    window.editTaskFromKanban = editTaskFromKanban;
    window.editIssueFromKanban = editIssueFromKanban;
    window.loadRelationshipFields = loadRelationshipFields;
    window.showAppropriateDivsByIssueType = showAppropriateDivsByIssueType;
    window.removeAttachment = removeAttachment;
    window.removeIssueAttachment = removeIssueAttachment;
    
    // Add handler for issue type changes in the form
    const issueTypeSelect = document.getElementById('issueType');
    if (issueTypeSelect) {
        issueTypeSelect.addEventListener('change', function() {
            const selectedType = this.value;
            if (selectedType) {
                showAppropriateDivsByIssueType(selectedType);
            }
        });
    }
    
    // Modify rendering to connect edit buttons
    modifyRenderColumnIssues();
    
    // Add handlers for modal resets
    const createTaskModal = document.getElementById('createTaskModal');
    if (createTaskModal) {
        createTaskModal.addEventListener('hidden.bs.modal', function() {
            // Reset edit mode when modal is closed
            isEditMode = false;
            
            // Reset form
            const form = document.getElementById('createTaskForm');
            if (form) {
                form.reset();
                delete form.dataset.taskId;
            }
            
            // Reset modal title and button
            const modalTitle = this.querySelector('.modal-title');
            const submitBtn = this.querySelector('button[type="submit"]');
            
            if (modalTitle) modalTitle.textContent = 'Create Task';
            if (submitBtn) submitBtn.textContent = 'Create Task';
            
            // Clear attachment list
            const attachmentList = document.getElementById('attachmentList');
            if (attachmentList) attachmentList.innerHTML = '';
        });
    }
    
    const createIssueModal = document.getElementById('createIssueModal');
    if (createIssueModal) {
        createIssueModal.addEventListener('hidden.bs.modal', function() {
            // Reset edit mode when modal is closed
            isEditMode = false;
            
            // Reset form
            const form = document.getElementById('createIssueForm');
            if (form) {
                form.reset();
                delete form.dataset.issueId;
            }
            
            // Reset modal title and button
            const modalTitle = this.querySelector('.modal-title');
            const submitBtn = this.querySelector('button[type="submit"]');
            
            if (modalTitle) modalTitle.textContent = 'Create Issue';
            if (submitBtn) submitBtn.textContent = 'Create Issue';
            
            // Clear attachment list
            const attachmentList = document.getElementById('issueAttachmentList');
            if (attachmentList) attachmentList.innerHTML = '';
        });
    }
    
    // Modify the modal show handlers to ensure we don't add duplicate listeners
    const taskModal = document.getElementById('createTaskModal');
    const issueModal = document.getElementById('createIssueModal');
    
    if (taskModal) {
        // Remove existing event listeners for shown.bs.modal by using once:true
        taskModal.addEventListener('shown.bs.modal', function() {
            console.log('Task modal shown - one-time initialization');
            
            // Don't call initializeTaskAttachments directly - already handled
            if (typeof enhancedCategoryChangeHandler === 'function') {
                enhancedCategoryChangeHandler();
            }
        }, { once: false });
    }
    
    if (issueModal) {
        // Handle issue modal shown event with once:true to prevent duplicate handlers
        issueModal.addEventListener('shown.bs.modal', function() {
            console.log('Issue modal shown - one-time initialization');
            
            // If issue type is already selected, trigger a change
            const issueType = document.getElementById('issueType');
            if (issueType && issueType.value) {
                console.log('Issue type already selected, triggering change event');
                const event = new Event('change');
                issueType.dispatchEvent(event);
            }
        }, { once: false });
    }
});


</script>



{% endblock %}